<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="color-scheme" content="light">
    <title>Lichess - Kindle</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
<style>
/* Kindle Paperwhite Optimized Styles */
/* High contrast grayscale, no animations, large touch targets */

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    -webkit-tap-highlight-color: transparent;
}

html, body {
    font-family: Georgia, 'Times New Roman', serif;
    font-size: 16px;
    line-height: 1.4;
    background: #fff;
    color: #000;
    min-height: 100vh;
    -webkit-text-size-adjust: 100%;
}

#app {
    max-width: 100%;
    padding: 8px;
}

/* Screens */
.screen {
    display: block;
}

.screen.hidden {
    display: none;
}

/* Typography */
h1 {
    font-size: 32px;
    text-align: center;
    margin: 40px 0 8px;
    font-weight: normal;
}

h2 {
    font-size: 20px;
    margin: 16px 0 12px;
    font-weight: normal;
    border-bottom: 1px solid #000;
    padding-bottom: 4px;
}

h3 {
    font-size: 16px;
    margin: 12px 0 8px;
    font-weight: bold;
}

.subtitle {
    text-align: center;
    font-style: italic;
    margin-bottom: 32px;
    color: #444;
}

/* Buttons */
.btn {
    display: inline-block;
    padding: 12px 20px;
    font-size: 16px;
    font-family: inherit;
    background: #fff;
    color: #000;
    border: 2px solid #000;
    cursor: pointer;
    min-height: 44px;
    min-width: 44px;
}

.btn:active {
    background: #000;
    color: #fff;
}

.btn-large {
    display: block;
    width: 100%;
    padding: 16px;
    font-size: 18px;
    margin: 8px 0;
}

.btn-small {
    padding: 8px 12px;
    font-size: 14px;
}

.btn:disabled {
    opacity: 0.5;
    cursor: default;
}

/* Header */
header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid #000;
    margin-bottom: 12px;
}

/* Time Controls Grid */
#time-controls {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    margin-bottom: 16px;
}

.time-btn {
    padding: 14px 8px;
    font-size: 14px;
    text-align: center;
}

/* Seeking State */
#seeking {
    text-align: center;
    padding: 20px;
    border: 2px dashed #666;
    margin: 16px 0;
}

/* Games List */
#games-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.game-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    border: 1px solid #000;
}

/* Chess Board */
#board {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
    border: 3px solid #000;
    margin: 8px auto;
    width: 95vw;
    max-width: 600px;
    height: 95vw;
    max-height: 600px;
}

.square {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
    cursor: pointer;
    position: relative;
    user-select: none;
    -webkit-user-select: none;
}

.square.light {
    background: #fff;
}

.square.dark {
    background: #999;
}

.square.selected {
    background: #666 !important;
}

.square.legal-move::after {
    content: '';
    position: absolute;
    width: 30%;
    height: 30%;
    background: #333;
    border-radius: 50%;
    opacity: 0.6;
}

.square.legal-capture::after {
    content: '';
    position: absolute;
    width: 90%;
    height: 90%;
    border: 4px solid #333;
    border-radius: 50%;
    opacity: 0.6;
}

.square.last-move {
    background: #bbb !important;
}

.square.check {
    background: #777 !important;
}

/* Pieces - using Unicode symbols for simplicity */
.piece {
    font-size: 32px;
    line-height: 1;
    pointer-events: none;
}

.piece.white {
    color: #fff;
    text-shadow: 
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000,
        1px 1px 0 #000,
        0 0 2px #000;
}

.piece.black {
    color: #000;
}

/* Player Info */
.player-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    max-width: 320px;
    margin: 4px auto;
    border: 1px solid #000;
    background: #f0f0f0;
}

.player-info.opponent {
    border-bottom: none;
}

.player-info.player {
    border-top: none;
}

.clock {
    font-family: 'Courier New', monospace;
    font-size: 20px;
    font-weight: bold;
    min-width: 60px;
    text-align: right;
}

.clock.low-time {
    background: #000;
    color: #fff;
    padding: 2px 6px;
}

/* Game Header */
.game-header {
    margin-bottom: 8px;
}

#game-status {
    font-weight: bold;
}

/* Game Controls */
#game-controls {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin-top: 12px;
    max-width: 320px;
    margin-left: auto;
    margin-right: auto;
}

#game-controls .btn {
    flex: 1;
}

/* Game Result */
#game-result {
    text-align: center;
    padding: 20px;
    margin-top: 16px;
    border: 3px solid #000;
    background: #f0f0f0;
    max-width: 320px;
    margin-left: auto;
    margin-right: auto;
}

#result-text {
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 16px;
}

/* Modal */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
}

.modal.hidden {
    display: none;
}

.modal-content {
    text-align: center;
    padding: 20px;
    border: 3px solid #000;
    background: #fff;
}

.promotion-pieces {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin-top: 12px;
}

.promo-btn {
    width: 50px;
    height: 50px;
    font-size: 32px;
    background: #fff;
    border: 2px solid #000;
    cursor: pointer;
}

.promo-btn:active {
    background: #000;
    color: #fff;
}

/* Utility */
.hidden {
    display: none !important;
}

/* Error Banner */
.error-banner {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: #000;
    color: #fff;
    padding: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 200;
}

.error-banner .btn-small {
    background: transparent;
    color: #fff;
    border-color: #fff;
    padding: 4px 10px;
}

/* Help Text */
.help-text {
    text-align: center;
    font-size: 14px;
    color: #666;
    margin-top: 24px;
    font-style: italic;
}

/* Coordinate labels - optional, off by default for simplicity */
.coord {
    position: absolute;
    font-size: 10px;
    opacity: 0.6;
}

.coord-file {
    bottom: 1px;
    right: 2px;
}

.coord-rank {
    top: 1px;
    left: 2px;
}

/* Debug Log - visible on screen for Kindle debugging */
.debug-log {
    margin-top: 20px;
    padding: 12px;
    border: 1px solid #666;
    background: #f5f5f5;
    font-family: 'Courier New', monospace;
    font-size: 11px;
    text-align: left;
    max-height: 300px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.debug-log .debug-line {
    margin: 2px 0;
    border-bottom: 1px dotted #ccc;
}

.debug-log .debug-error {
    color: #000;
    font-weight: bold;
    background: #ddd;
    padding: 2px 4px;
}

.debug-log .debug-ok {
    color: #000;
}

</style>
</head>
<body>
<div id="app">
    <!-- Loading Screen -->
    <div id="screen-loading" class="screen">
        <h1>♔ Lichess</h1>
        <p class="subtitle">Loading...</p>
        <div id="debug-log" class="debug-log"></div>
    </div>

    <!-- Error Display -->
    <div id="error-banner" class="error-banner hidden">
        <span id="error-message"></span>
        <button id="btn-dismiss-error" class="btn btn-small">×</button>
    </div>

    <!-- Login Screen -->
    <div id="screen-login" class="screen hidden">
        <h1>♔ Lichess</h1>
        <p class="subtitle">Kindle Edition</p>
        <button id="btn-login" class="btn btn-large">Login with Lichess</button>
        <p class="help-text">You'll be redirected to Lichess to authorize this app.</p>
    </div>

    <!-- Lobby Screen -->
    <div id="screen-lobby" class="screen hidden">
        <header>
            <span id="username">Player</span>
            <button id="btn-logout" class="btn btn-small">Logout</button>
        </header>

        <h2>New Game</h2>

        <div id="time-controls">
            <!-- Time control buttons generated by JS -->
        </div>

        <div id="seeking" class="hidden">
            <p>Seeking opponent...</p>
            <button id="btn-cancel-seek" class="btn">Cancel</button>
        </div>

        <div id="ongoing-games" class="hidden">
            <h3>Ongoing Games</h3>
            <div id="games-list"></div>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="screen-game" class="screen hidden">
        <header class="game-header">
            <button id="btn-back" class="btn btn-small">← Back</button>
            <span id="game-status">Playing</span>
        </header>

        <div class="player-info opponent">
            <span id="opponent-name">Opponent</span>
            <span id="opponent-clock" class="clock">--:--</span>
        </div>

        <div id="board">
            <!-- 8x8 board generated by JS -->
        </div>

        <div class="player-info player">
            <span id="player-name">You</span>
            <span id="player-clock" class="clock">--:--</span>
        </div>

        <div id="game-controls">
            <button id="btn-resign" class="btn">Resign</button>
            <button id="btn-draw" class="btn">Offer Draw</button>
        </div>

        <div id="game-result" class="hidden">
            <p id="result-text"></p>
            <button id="btn-new-game" class="btn btn-large">New Game</button>
        </div>

        <div id="promotion-modal" class="modal hidden">
            <div class="modal-content">
                <p>Promote to:</p>
                <div class="promotion-pieces">
                    <button class="promo-btn" data-piece="q">♛</button>
                    <button class="promo-btn" data-piece="r">♜</button>
                    <button class="promo-btn" data-piece="b">♝</button>
                    <button class="promo-btn" data-piece="n">♞</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
// IMMEDIATE TEST - Write directly to page before ANY other code
document.getElementById('debug-log').innerHTML = 'JS RUNNING!<br>';

// Ultra-simple logger with maximum compatibility
(function() {
    var logs = ['JS RUNNING!'];
    var count = 1;

    window.log = function(msg) {
        count++;
        var time = new Date().toLocaleTimeString();
        var logLine = count + '. [' + time + '] ' + String(msg);
        logs.push(logLine);
        if (logs.length > 50) logs.shift();

        // Update debug div
        try {
            var debugDiv = document.getElementById('debug-log');
            if (debugDiv) {
                debugDiv.innerHTML = logs.join('<br>\n');
                debugDiv.scrollTop = 99999;
            }
        } catch(e) {
            // Ignore errors in logger itself
        }
    };

    window.onerror = function(msg, url, line) {
        log('ERROR: ' + msg + ' at line ' + line);
        return true;
    };

    try {
        window.addEventListener('unhandledrejection', function(e) {
            log('PROMISE ERROR: ' + (e.reason || 'unknown'));
        });
    } catch(e) {
        // addEventListener might not exist
    }

    log('1. Logger initialized');
    log('2. Testing basic features...');
    log('3. typeof Promise: ' + typeof Promise);
    log('4. typeof fetch: ' + typeof fetch);
    log('5. typeof TextEncoder: ' + typeof TextEncoder);

    // Test async/await support
    try {
        eval('(async function(){})()');
        log('6. async/await: SUPPORTED');
    } catch(e) {
        log('6. async/await: ERROR - ' + e.message);
    }

    log('7. Starting app load...');
})();

// Polyfills for Kindle Browser Compatibility
// These provide fallbacks for missing modern browser APIs

(function() {
    'use strict';

    // ============================================
    // TextEncoder / TextDecoder Polyfills
    // ============================================

    if (typeof TextEncoder === 'undefined') {
        window.TextEncoder = function TextEncoder() {};
        TextEncoder.prototype.encode = function encode(str) {
            var utf8 = [];
            for (var i = 0; i < str.length; i++) {
                var charcode = str.charCodeAt(i);
                if (charcode < 0x80) {
                    utf8.push(charcode);
                } else if (charcode < 0x800) {
                    utf8.push(0xc0 | (charcode >> 6),
                              0x80 | (charcode & 0x3f));
                } else if (charcode < 0xd800 || charcode >= 0xe000) {
                    utf8.push(0xe0 | (charcode >> 12),
                              0x80 | ((charcode >> 6) & 0x3f),
                              0x80 | (charcode & 0x3f));
                } else {
                    i++;
                    charcode = 0x10000 + (((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
                    utf8.push(0xf0 | (charcode >> 18),
                              0x80 | ((charcode >> 12) & 0x3f),
                              0x80 | ((charcode >> 6) & 0x3f),
                              0x80 | (charcode & 0x3f));
                }
            }
            return new Uint8Array(utf8);
        };
    }

    if (typeof TextDecoder === 'undefined') {
        window.TextDecoder = function TextDecoder() {};
        TextDecoder.prototype.decode = function decode(bytes) {
            var str = '';
            var i = 0;
            while (i < bytes.length) {
                var byte1 = bytes[i];
                if (byte1 < 0x80) {
                    str += String.fromCharCode(byte1);
                    i++;
                } else if (byte1 >= 0xc0 && byte1 < 0xe0) {
                    var byte2 = bytes[i + 1];
                    str += String.fromCharCode(((byte1 & 0x1f) << 6) | (byte2 & 0x3f));
                    i += 2;
                } else if (byte1 >= 0xe0 && byte1 < 0xf0) {
                    var byte2 = bytes[i + 1];
                    var byte3 = bytes[i + 2];
                    str += String.fromCharCode(((byte1 & 0x0f) << 12) | ((byte2 & 0x3f) << 6) | (byte3 & 0x3f));
                    i += 3;
                } else {
                    var byte2 = bytes[i + 1];
                    var byte3 = bytes[i + 2];
                    var byte4 = bytes[i + 3];
                    var codepoint = ((byte1 & 0x07) << 18) | ((byte2 & 0x3f) << 12) | ((byte3 & 0x3f) << 6) | (byte4 & 0x3f);
                    codepoint -= 0x10000;
                    str += String.fromCharCode((codepoint >> 10) + 0xd800, (codepoint & 0x3ff) + 0xdc00);
                    i += 4;
                }
            }
            return str;
        };
    }

    // ============================================
    // Crypto Polyfill for SHA-256
    // ============================================

    // Check if crypto.subtle.digest exists
    if (!window.crypto || !window.crypto.subtle || !window.crypto.subtle.digest) {
        console.warn('crypto.subtle.digest not available, using fallback SHA-256');

        // Simplified SHA-256 implementation
        // Based on https://github.com/emn178/js-sha256
        function sha256Hash(bytes) {
            var h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;
            var h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;
            var w = [];
            var a, b, c, d, e, f, g, h, i, j, t1, t2;
            var k = [
                0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
                0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
                0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
                0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
                0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
                0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
            ];

            // Padding
            var msgLen = bytes.length;
            var bitLen = msgLen * 8;
            var paddedLen = ((msgLen + 8) >> 6 << 4) + 16;
            var blocks = new Uint32Array(paddedLen);

            // Copy bytes to blocks
            for (i = 0; i < msgLen; i++) {
                blocks[i >> 2] |= bytes[i] << (24 - (i % 4) * 8);
            }

            // Append 1 bit and length
            blocks[msgLen >> 2] |= 0x80 << (24 - (msgLen % 4) * 8);
            blocks[paddedLen - 1] = bitLen;
            blocks[paddedLen - 2] = (bitLen / 0x100000000) | 0;

            // Process blocks
            for (i = 0; i < paddedLen; i += 16) {
                a = h0; b = h1; c = h2; d = h3;
                e = h4; f = h5; g = h6; h = h7;

                for (j = 0; j < 64; j++) {
                    if (j < 16) {
                        w[j] = blocks[i + j];
                    } else {
                        var s0 = rightRotate(w[j - 15], 7) ^ rightRotate(w[j - 15], 18) ^ (w[j - 15] >>> 3);
                        var s1 = rightRotate(w[j - 2], 17) ^ rightRotate(w[j - 2], 19) ^ (w[j - 2] >>> 10);
                        w[j] = (w[j - 16] + s0 + w[j - 7] + s1) | 0;
                    }

                    var S1 = rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25);
                    var ch = (e & f) ^ (~e & g);
                    t1 = (h + S1 + ch + k[j] + w[j]) | 0;
                    var S0 = rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22);
                    var maj = (a & b) ^ (a & c) ^ (b & c);
                    t2 = (S0 + maj) | 0;

                    h = g; g = f; f = e;
                    e = (d + t1) | 0;
                    d = c; c = b; b = a;
                    a = (t1 + t2) | 0;
                }

                h0 = (h0 + a) | 0; h1 = (h1 + b) | 0;
                h2 = (h2 + c) | 0; h3 = (h3 + d) | 0;
                h4 = (h4 + e) | 0; h5 = (h5 + f) | 0;
                h6 = (h6 + g) | 0; h7 = (h7 + h) | 0;
            }

            // Return hash as ArrayBuffer
            var hash = new Uint8Array(32);
            hash[0] = (h0 >>> 24) & 0xff; hash[1] = (h0 >>> 16) & 0xff;
            hash[2] = (h0 >>> 8) & 0xff;  hash[3] = h0 & 0xff;
            hash[4] = (h1 >>> 24) & 0xff; hash[5] = (h1 >>> 16) & 0xff;
            hash[6] = (h1 >>> 8) & 0xff;  hash[7] = h1 & 0xff;
            hash[8] = (h2 >>> 24) & 0xff; hash[9] = (h2 >>> 16) & 0xff;
            hash[10] = (h2 >>> 8) & 0xff; hash[11] = h2 & 0xff;
            hash[12] = (h3 >>> 24) & 0xff; hash[13] = (h3 >>> 16) & 0xff;
            hash[14] = (h3 >>> 8) & 0xff;  hash[15] = h3 & 0xff;
            hash[16] = (h4 >>> 24) & 0xff; hash[17] = (h4 >>> 16) & 0xff;
            hash[18] = (h4 >>> 8) & 0xff;  hash[19] = h4 & 0xff;
            hash[20] = (h5 >>> 24) & 0xff; hash[21] = (h5 >>> 16) & 0xff;
            hash[22] = (h5 >>> 8) & 0xff;  hash[23] = h5 & 0xff;
            hash[24] = (h6 >>> 24) & 0xff; hash[25] = (h6 >>> 16) & 0xff;
            hash[26] = (h6 >>> 8) & 0xff;  hash[27] = h6 & 0xff;
            hash[28] = (h7 >>> 24) & 0xff; hash[29] = (h7 >>> 16) & 0xff;
            hash[30] = (h7 >>> 8) & 0xff;  hash[31] = h7 & 0xff;

            return hash.buffer;
        }

        function rightRotate(n, b) {
            return (n >>> b) | (n << (32 - b));
        }

        // Create polyfill
        if (!window.crypto) {
            window.crypto = {};
        }
        if (!window.crypto.subtle) {
            window.crypto.subtle = {};
        }

        window.crypto.subtle.digest = function(algorithm, data) {
            return new Promise(function(resolve, reject) {
                try {
                    if (algorithm === 'SHA-256') {
                        var bytes = new Uint8Array(data);
                        var hash = sha256Hash(bytes);
                        resolve(hash);
                    } else {
                        reject(new Error('Unsupported algorithm: ' + algorithm));
                    }
                } catch (e) {
                    reject(e);
                }
            });
        };
    }

    // ============================================
    // URLSearchParams Polyfill
    // ============================================

    if (typeof URLSearchParams === 'undefined' || !URLSearchParams.prototype.toString) {
        window.URLSearchParams = function(init) {
            this.params = {};

            if (typeof init === 'string') {
                var pairs = init.replace(/^\?/, '').split('&');
                for (var i = 0; i < pairs.length; i++) {
                    var pair = pairs[i].split('=');
                    if (pair[0]) {
                        this.params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
                    }
                }
            } else if (typeof init === 'object') {
                for (var key in init) {
                    if (init.hasOwnProperty(key)) {
                        this.params[key] = init[key];
                    }
                }
            }
        };

        URLSearchParams.prototype.get = function(name) {
            return this.params[name] || null;
        };

        URLSearchParams.prototype.set = function(name, value) {
            this.params[name] = String(value);
        };

        URLSearchParams.prototype.toString = function() {
            var parts = [];
            for (var key in this.params) {
                if (this.params.hasOwnProperty(key)) {
                    parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(this.params[key]));
                }
            }
            return parts.join('&');
        };
    }

    // ============================================
    // Promise.prototype.finally Polyfill
    // ============================================

    if (typeof Promise !== 'undefined' && !Promise.prototype.finally) {
        Promise.prototype.finally = function(callback) {
            var P = this.constructor;
            return this.then(
                function(value) {
                    return P.resolve(callback()).then(function() { return value; });
                },
                function(reason) {
                    return P.resolve(callback()).then(function() { throw reason; });
                }
            );
        };
    }

    // Mark that polyfills loaded
    window.POLYFILLS_LOADED = true;

    // Try to log (console might not be overridden yet)
    if (window.console && window.console.log) {
        window.console.log('✓ Polyfills loaded successfully');
    }
})();


// Lichess OAuth Configuration
// 
// IMPORTANT: Lichess uses UNREGISTERED/PUBLIC clients!
// You do NOT need to register an app. Just pick a unique client ID.
// 
// HOW IT WORKS:
// 1. Choose a unique client_id for your app (e.g., 'kindle-chess-yourname')
// 2. That's it! No registration, no client secret needed.
// 3. Users will be redirected to Lichess to authorize your app
//
// See: https://lichess.org/api#tag/OAuth
// "Lichess supports unregistered and public clients (no client authentication, 
//  choose any unique client id)"

var CONFIG = {
    // Choose a unique client ID for your app
    // Convention: lowercase, use hyphens, make it descriptive and unique
    // Examples: 'kindle-chess-lev', 'my-chess-app-2024', 'chess-viewer-mobile'
    LICHESS_CLIENT_ID: 'kindle-lichess-client',
    
    // Redirect URI - auto-detects from current URL
    // For local testing: http://localhost:4280/
    // For Azure: https://your-app.azurestaticapps.net/
    REDIRECT_URI: window.location.origin + '/',
    
    // Lichess API endpoints
    LICHESS_HOST: 'https://lichess.org',
    
    // OAuth endpoints (for reference)
    // Authorization: https://lichess.org/oauth
    // Token exchange: https://lichess.org/api/token
    
    // Available time controls (in minutes + increment in seconds)
    TIME_CONTROLS: [
        { name: '10+0 Rapid', time: 10, increment: 0 },
        { name: '10+5 Rapid', time: 10, increment: 5 },
        { name: '15+10 Rapid', time: 15, increment: 10 },
        { name: '30+0 Classical', time: 30, increment: 0 }
    ],
    
    // UI Settings optimized for Kindle
    SETTINGS: {
        // Show coordinates on board edge
        showCoordinates: false,
        // Confirm moves before sending (adds extra tap)
        confirmMoves: false,
        // Low time warning threshold (seconds)
        lowTimeThreshold: 30
    }
};


// Lichess Kindle Client - Main Application
// No dependencies, vanilla JS

// Log immediately to catch early errors
if (window.console && window.console.log) {
    window.log('>>> app.js loading...');
}

// Debug logging handled by window.log() function above

// Override console to use simple log
console.log = function() {
    var message = Array.prototype.slice.call(arguments).join(' ');
    log(message);
};

console.error = function() {
    var message = 'ERROR: ' + Array.prototype.slice.call(arguments).join(' ');
    log(message);
};

console.warn = function() {
    var message = 'WARN: ' + Array.prototype.slice.call(arguments).join(' ');
    log(message);
};

// ============================================
// State
// ============================================

var state = {
    token: null,
    user: null,
    currentGame: null,
    board: null,
    selectedSquare: null,
    legalMoves: [],
    orientation: 'white',
    pendingPromotion: null,
    eventSource: null,
    seekEventSource: null,
    seekReader: null,
    eventStreamReader: null,
    clockInterval: null,
    lastClockUpdate: null,
    whiteTime: null,
    blackTime: null,
    isWhiteTurn: true
};

// ============================================
// Utility Functions
// ============================================

function $(id) {
    return document.getElementById(id);
}

function show(id) {
    $(id).classList.remove('hidden');
}

function hide(id) {
    $(id).classList.add('hidden');
}

function showScreen(screenId) {
    document.querySelectorAll('.screen').forEach(function(s) {
        s.classList.add('hidden');
    });
    $(screenId).classList.remove('hidden');
}

function showError(message) {
    $('error-message').textContent = message;
    show('error-banner');
    
    // Auto-hide after 5 seconds
    setTimeout(function() {
        hide('error-banner');
    }, 5000);
}

function dismissError() {
    hide('error-banner');
}

// Generate random string for OAuth PKCE
function generateRandomString(length) {
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    var result = '';
    var values = new Uint8Array(length);
    window.crypto.getRandomValues(values);
    for (var i = 0; i < length; i++) {
        result += chars[values[i] % chars.length];
    }
    return result;
}

// SHA256 hash for PKCE
function sha256(plain) {
    var encoder = new TextEncoder();
    var data = encoder.encode(plain);
    return window.crypto.subtle.digest('SHA-256', data);
}

// Base64 URL encode
function base64UrlEncode(arrayBuffer) {
    var bytes = new Uint8Array(arrayBuffer);
    var binary = '';
    for (var i = 0; i < bytes.length; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary)
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
}

// Format time for clock display
function formatTime(seconds) {
    if (seconds === undefined || seconds === null) return '--:--';
    var mins = Math.floor(seconds / 60);
    var secs = seconds % 60;
    return mins + ':' + (secs < 10 ? '0' : '') + secs;
}

// Fetch with timeout for Kindle compatibility
function fetchWithTimeout(url, options, timeout) {
    timeout = timeout || 30000; // 30 second default

    return new Promise(function(resolve, reject) {
        var timedOut = false;
        var timer = setTimeout(function() {
            timedOut = true;
            reject(new Error('Request timeout'));
        }, timeout);

        fetch(url, options)
            .then(function(response) {
                clearTimeout(timer);
                if (!timedOut) {
                    resolve(response);
                }
            })
            .catch(function(error) {
                clearTimeout(timer);
                if (!timedOut) {
                    reject(error);
                }
            });
    });
}

// ============================================
// OAuth Authentication
// ============================================

function startLogin() {
    log('Starting login...');
    var codeVerifier = generateRandomString(64);
    localStorage.setItem('pkce_verifier', codeVerifier);

    log('Hashing code verifier...');
    sha256(codeVerifier).then(function(hashed) {
        var codeChallenge = base64UrlEncode(hashed);
        log('Hash complete');

        var params = new URLSearchParams({
            response_type: 'code',
            client_id: CONFIG.LICHESS_CLIENT_ID,
            redirect_uri: CONFIG.REDIRECT_URI,
            scope: 'board:play',
            code_challenge_method: 'S256',
            code_challenge: codeChallenge
        });

        window.location.href = CONFIG.LICHESS_HOST + '/oauth?' + params.toString();
    }).catch(function(err) {
        log('Login failed:', err);
        showError('Login failed: ' + err.message);
        showScreen('screen-login');
    });
}

function handleOAuthCallback() {
    var params = new URLSearchParams(window.location.search);
    var code = params.get('code');
    
    if (!code) return Promise.resolve(false);
    
    var codeVerifier = localStorage.getItem('pkce_verifier');
    if (!codeVerifier) {
        log('No code verifier found');
        return Promise.resolve(false);
    }
    
    log('Exchanging OAuth code for token...');
    return fetchWithTimeout(CONFIG.LICHESS_HOST + '/api/token', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: new URLSearchParams({
            grant_type: 'authorization_code',
            code: code,
            code_verifier: codeVerifier,
            redirect_uri: CONFIG.REDIRECT_URI,
            client_id: CONFIG.LICHESS_CLIENT_ID
        }).toString()
    }, 30000).then(function(response) {
        if (!response.ok) {
            log('Token exchange failed with status:', response.status);
            throw new Error('Token exchange failed');
        }
        return response.json();
    }).then(function(data) {
        state.token = data.access_token;
        localStorage.setItem('lichess_token', state.token);
        localStorage.removeItem('pkce_verifier');

        log('OAuth success');
        // Clean URL
        window.history.replaceState({}, document.title, '/');

        return true;
    }).catch(function(err) {
        log('OAuth error:', err);
        showError('OAuth failed: ' + err.message);
        return false;
    });
}

function checkAuth() {
    state.token = localStorage.getItem('lichess_token');
    if (!state.token) return Promise.resolve(false);

    log('Checking authentication...');
    return fetchWithTimeout(CONFIG.LICHESS_HOST + '/api/account', {
        headers: { 'Authorization': 'Bearer ' + state.token }
    }, 20000).then(function(response) {
        if (!response.ok) {
            log('Auth check failed, clearing token');
            localStorage.removeItem('lichess_token');
            state.token = null;
            return false;
        }

        return response.json().then(function(user) {
            state.user = user;
            log('Authenticated as:', state.user.username);
            return true;
        });
    }).catch(function(err) {
        log('Auth check failed:', err);
        showError('Connection failed: ' + err.message);
        localStorage.removeItem('lichess_token');
        state.token = null;
        return false;
    });
}

function logout() {
    localStorage.removeItem('lichess_token');
    state.token = null;
    state.user = null;
    if (state.eventSource) state.eventSource.close();
    if (state.seekEventSource) state.seekEventSource.close();
    stopEventStream();
    showScreen('screen-login');
}

// ============================================
// Lobby & Game Seeking
// ============================================

function showLobby() {
    $('username').textContent = state.user.username;
    renderTimeControls();
    showScreen('screen-lobby');
    checkOngoingGames();
}

function renderTimeControls() {
    var container = $('time-controls');
    container.innerHTML = '';
    
    CONFIG.TIME_CONTROLS.forEach(function(tc) {
        var btn = document.createElement('button');
        btn.className = 'btn time-btn';
        btn.textContent = tc.name;
        btn.onclick = function() {
            seekGame(tc.time, tc.increment);
        };
        container.appendChild(btn);
    });
}

function checkOngoingGames() {
    return fetchWithTimeout(CONFIG.LICHESS_HOST + '/api/account/playing', {
        headers: { 'Authorization': 'Bearer ' + state.token }
    }, 15000).then(function(response) {
        if (!response.ok) return;

        return response.json().then(function(data) {
            var games = data.nowPlaying || [];

            if (games.length > 0) {
                show('ongoing-games');
                var list = $('games-list');
                list.innerHTML = '';

                games.forEach(function(game) {
                    var div = document.createElement('div');
                    div.className = 'game-item';
                    div.innerHTML =
                        '<span>vs ' + game.opponent.username + '</span>' +
                        '<button class="btn btn-small">Resume</button>';
                    div.querySelector('button').onclick = function() {
                        joinGame(game.gameId);
                    };
                    list.appendChild(div);
                });
            } else {
                hide('ongoing-games');
            }
        });
    }).catch(function(err) {
        log('Failed to check ongoing games:', err);
    });
}

function seekGame(minutes, increment) {
    show('seeking');
    
    // First, start listening to the event stream to catch game start
    startEventStream();
    
    // Create the seek - this will stream until cancelled or game found
    fetchWithTimeout(CONFIG.LICHESS_HOST + '/api/board/seek', {
        method: 'POST',
        headers: {
            'Authorization': 'Bearer ' + state.token,
            'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: new URLSearchParams({
            time: minutes,
            increment: increment,
            rated: 'true',
            variant: 'standard',
            color: 'random'
        }).toString()
    }, 120000).then(function(response) {
        if (!response.ok) {
            var errorMsg = 'Seek failed: ' + response.status;
            return response.text().then(function(errorBody) {
                if (errorBody) {
                    log('Seek error body:', errorBody);
                    errorMsg += ' - ' + errorBody;
                }
                throw new Error(errorMsg);
            }, function() {
                throw new Error(errorMsg);
            });
        }
        
        // The seek stream stays open while waiting for an opponent
        // Game start notification comes via the event stream
        // Keep reading to keep the seek alive
        var reader = response.body.getReader();
        var decoder = new TextDecoder();
        
        state.seekReader = reader;

        function readSeekChunk() {
            reader.read().then(function(result) {
                if (result.done) {
                    log('Seek stream ended');
                    // Stream ended without finding game
                    hide('seeking');
                    showError('No opponent found. Try again.');
                    return;
                }
                
                var text = decoder.decode(result.value);
                log('Seek stream data:', text);
                
                // Sometimes the game ID comes directly in the seek response
                var lines = text.split('\n').filter(function(l) { return l.trim(); });
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    try {
                        var event = JSON.parse(line);
                        log('Seek event:', event);
                        if (event.id) {
                            hide('seeking');
                            joinGame(event.id);
                            return;
                        }
                    } catch (e) {}
                }

                // Continue reading
                readSeekChunk();
            }).catch(function(err) {
                log('Seek stream read error:', err);
                hide('seeking');
                if (err.name !== 'AbortError') {
                    showError('Failed to find game. Please try again.');
                }
            });
        }

        readSeekChunk();
    }).catch(function(err) {
        log('Seek error:', err);
        hide('seeking');
        if (err.name !== 'AbortError') {
            showError('Failed to find game. Please try again.');
        }
    });
}

// Event stream to receive game start notifications
function startEventStream() {
    if (state.eventStreamReader) {
        return; // Already listening
    }

    log('Starting event stream...');

    fetch(CONFIG.LICHESS_HOST + '/api/stream/event', {
        headers: { 'Authorization': 'Bearer ' + state.token }
    }).then(function(response) {
        if (!response.ok) {
            log('Event stream failed:', response.status);
            return;
        }

        var reader = response.body.getReader();
        var decoder = new TextDecoder();
        state.eventStreamReader = reader;

        // Iterative reading to avoid stack overflow on Kindle
        function readChunk() {
            reader.read().then(function(result) {
                if (result.done) {
                    log('Event stream ended');
                    state.eventStreamReader = null;
                    return;
                }

                try {
                    var text = decoder.decode(result.value, { stream: true });
                    var lines = text.split('\n');

                    for (var i = 0; i < lines.length; i++) {
                        var line = lines[i].trim();
                        if (line) {
                            try {
                                var event = JSON.parse(line);
                                log('Event:', event);
                                handleIncomingEvent(event);
                            } catch (e) {
                                log('Failed to parse event line:', e);
                            }
                        }
                    }
                } catch (e) {
                    log('Failed to decode stream:', e);
                }

                // Continue reading (async, no recursion)
                setTimeout(readChunk, 0);
            }).catch(function(err) {
                log('Event stream error:', err);
                state.eventStreamReader = null;
            });
        }

        readChunk();
    }).catch(function(err) {
        log('Failed to start event stream:', err);
    });
}

function handleIncomingEvent(event) {
    if (event.type === 'gameStart') {
        log('Game started!', event.game);
        hide('seeking');
        
        // Cancel the seek stream
        if (state.seekReader) {
            state.seekReader.cancel();
            state.seekReader = null;
        }
        
        joinGame(event.game.gameId || event.game.id);
    } else if (event.type === 'gameFinish') {
        log('Game finished', event.game);
        checkOngoingGames();
    } else if (event.type === 'challenge') {
        log('Challenge received', event.challenge);
        // Could show challenge notification here
    }
}

function stopEventStream() {
    if (state.eventStreamReader) {
        state.eventStreamReader.cancel();
        state.eventStreamReader = null;
    }
}

function cancelSeek() {
    // Cancel the seek stream
    if (state.seekReader) {
        state.seekReader.cancel();
        state.seekReader = null;
    }
    if (state.seekEventSource) {
        state.seekEventSource.close();
        state.seekEventSource = null;
    }
    hide('seeking');
}

// ============================================
// Game Logic
// ============================================

function joinGame(gameId) {
    state.currentGame = { id: gameId };
    state.board = null;
    state.selectedSquare = null;
    state.legalMoves = [];
    
    showScreen('screen-game');
    hide('game-result');
    show('game-controls');
    $('game-status').textContent = 'Connecting...';
    
    // Stream game events
    streamGame(gameId);
}

function streamGame(gameId) {
    if (state.eventSource) {
        state.eventSource.close();
    }

    log('Streaming game:', gameId);

    // Use fetch with streaming for better Kindle compatibility
    fetch(CONFIG.LICHESS_HOST + '/api/board/game/stream/' + gameId, {
        headers: { 'Authorization': 'Bearer ' + state.token }
    }).then(function(response) {
        if (!response.ok) {
            log('Game stream failed:', response.status);
            $('game-status').textContent = 'Connection failed';
            return;
        }

        var reader = response.body.getReader();
        var decoder = new TextDecoder();
        var buffer = '';

        // Iterative reading to avoid stack overflow on Kindle
        function readChunk() {
            reader.read().then(function(result) {
                if (result.done) {
                    log('Game stream ended');
                    return;
                }

                try {
                    buffer += decoder.decode(result.value, { stream: true });
                    var lines = buffer.split('\n');

                    // Keep last incomplete line in buffer
                    buffer = lines.pop() || '';

                    for (var i = 0; i < lines.length; i++) {
                        var line = lines[i].trim();
                        if (line) {
                            try {
                                var event = JSON.parse(line);
                                handleGameEvent(event);
                            } catch (e) {
                                log('Failed to parse game event:', e);
                            }
                        }
                    }
                } catch (e) {
                    log('Failed to decode game stream:', e);
                }

                // Continue reading (async, no recursion)
                setTimeout(readChunk, 0);
            }).catch(function(err) {
                log('Game stream error:', err);
                $('game-status').textContent = 'Connection lost';
            });
        }

        readChunk();
    }).catch(function(err) {
        log('Failed to stream game:', err);
        $('game-status').textContent = 'Connection failed';
        showError('Failed to connect to game');
    });
}

function handleGameEvent(event) {
    if (event.type === 'gameFull') {
        // Initial game state
        state.currentGame = state.currentGame || {};
        state.currentGame.white = event.white;
        state.currentGame.black = event.black;
        state.currentGame.initialFen = event.initialFen || 'startpos';
        
        // Determine orientation
        state.orientation = (event.white.id === state.user.id.toLowerCase()) ? 'white' : 'black';
        
        // Set player names
        if (state.orientation === 'white') {
            $('player-name').textContent = event.white.name || event.white.id;
            $('opponent-name').textContent = event.black.name || event.black.id;
        } else {
            $('player-name').textContent = event.black.name || event.black.id;
            $('opponent-name').textContent = event.white.name || event.white.id;
        }
        
        handleGameState(event.state);
        
    } else if (event.type === 'gameState') {
        handleGameState(event);
        
    } else if (event.type === 'chatLine') {
        // Ignore chat
    }
}

function handleGameState(gameState) {
    // Parse moves and build position
    var moves = gameState.moves ? gameState.moves.split(' ').filter(function(m) { return m; }) : [];
    state.board = buildPosition(moves);
    state.currentGame.moves = moves;
    state.currentGame.status = gameState.status;
    state.currentGame.winner = gameState.winner;
    
    // Calculate whose turn
    state.isWhiteTurn = moves.length % 2 === 0;
    var isMyTurn = (state.orientation === 'white') === state.isWhiteTurn;
    
    // Update clocks
    updateClocks(gameState.wtime, gameState.btime);
    
    // Update status
    if (gameState.status === 'started' || gameState.status === 'created') {
        $('game-status').textContent = isMyTurn ? 'Your turn' : "Opponent's turn";
    } else {
        stopClockTimer();
        showGameResult(gameState);
    }
    
    // Clear selection
    state.selectedSquare = null;
    state.legalMoves = [];
    
    renderBoard();
}

function updateClocks(wtime, btime) {
    state.whiteTime = Math.floor((wtime || 0) / 1000);
    state.blackTime = Math.floor((btime || 0) / 1000);
    state.lastClockUpdate = Date.now();
    
    renderClocks();
    startClockTimer();
}

function renderClocks() {
    var playerTime, opponentTime;
    if (state.orientation === 'white') {
        playerTime = state.whiteTime;
        opponentTime = state.blackTime;
    } else {
        playerTime = state.blackTime;
        opponentTime = state.whiteTime;
    }
    
    var playerClock = $('player-clock');
    var opponentClock = $('opponent-clock');
    
    playerClock.textContent = formatTime(Math.max(0, playerTime));
    opponentClock.textContent = formatTime(Math.max(0, opponentTime));
    
    var threshold = (CONFIG.SETTINGS && CONFIG.SETTINGS.lowTimeThreshold) || 30;
    playerClock.classList.toggle('low-time', playerTime < threshold);
    opponentClock.classList.toggle('low-time', opponentTime < threshold);
}

function startClockTimer() {
    // Clear existing timer
    if (state.clockInterval) {
        clearInterval(state.clockInterval);
    }
    
    // Only run timer during active game
    if (!state.currentGame || state.currentGame.status !== 'started') {
        return;
    }
    
    // Update clock every second
    state.clockInterval = setInterval(function() {
        if (!state.lastClockUpdate) return;
        
        var elapsed = Math.floor((Date.now() - state.lastClockUpdate) / 1000);
        
        if (state.isWhiteTurn) {
            state.whiteTime = Math.max(0, state.whiteTime - elapsed);
        } else {
            state.blackTime = Math.max(0, state.blackTime - elapsed);
        }
        
        state.lastClockUpdate = Date.now();
        renderClocks();
    }, 1000);
}

function stopClockTimer() {
    if (state.clockInterval) {
        clearInterval(state.clockInterval);
        state.clockInterval = null;
    }
}

function showGameResult(gameState) {
    hide('game-controls');
    show('game-result');
    
    var resultText = '';
    var status = gameState.status;
    var winner = gameState.winner;
    
    if (status === 'draw' || status === 'stalemate') {
        resultText = 'Draw';
    } else if (status === 'mate') {
        resultText = winner === state.orientation ? 'You won by checkmate!' : 'You lost by checkmate';
    } else if (status === 'resign') {
        resultText = winner === state.orientation ? 'Opponent resigned - You win!' : 'You resigned';
    } else if (status === 'timeout') {
        resultText = winner === state.orientation ? 'Opponent ran out of time - You win!' : 'You ran out of time';
    } else if (status === 'outoftime') {
        resultText = winner === state.orientation ? 'You win on time!' : 'You lost on time';
    } else {
        resultText = 'Game over: ' + status;
    }
    
    $('result-text').textContent = resultText;
    $('game-status').textContent = 'Game Over';
}

// ============================================
// Board Position & Move Generation
// ============================================

function buildPosition(moves) {
    // Start from initial position
    var board = [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
    ];
    
    // Apply each move
    for (var i = 0; i < moves.length; i++) {
        var move = moves[i];
        applyMove(board, move);
    }
    
    return board;
}

function applyMove(board, uci) {
    var fromFile = uci.charCodeAt(0) - 97;
    var fromRank = 8 - parseInt(uci[1]);
    var toFile = uci.charCodeAt(2) - 97;
    var toRank = 8 - parseInt(uci[3]);
    var promotion = uci[4];
    
    var piece = board[fromRank][fromFile];
    
    // Handle castling
    if (piece.toLowerCase() === 'k' && Math.abs(fromFile - toFile) === 2) {
        // Move king
        board[toRank][toFile] = piece;
        board[fromRank][fromFile] = '';
        
        // Move rook
        if (toFile > fromFile) {
            // Kingside
            board[toRank][5] = board[toRank][7];
            board[toRank][7] = '';
        } else {
            // Queenside
            board[toRank][3] = board[toRank][0];
            board[toRank][0] = '';
        }
        return;
    }
    
    // Handle en passant
    if (piece.toLowerCase() === 'p' && fromFile !== toFile && !board[toRank][toFile]) {
        board[fromRank][toFile] = '';
    }
    
    // Regular move
    board[toRank][toFile] = piece;
    board[fromRank][fromFile] = '';
    
    // Handle promotion
    if (promotion) {
        var isWhite = piece === 'P';
        board[toRank][toFile] = isWhite ? promotion.toUpperCase() : promotion.toLowerCase();
    }
}

function getLegalMoves(square) {
    // Simplified move generation - server validates anyway
    var file = square.charCodeAt(0) - 97;
    var rank = 8 - parseInt(square[1]);
    var piece = state.board[rank][file];
    
    if (!piece) return [];
    
    var isWhite = piece === piece.toUpperCase();
    var isMyPiece = (state.orientation === 'white') === isWhite;
    
    if (!isMyPiece) return [];
    
    var moves = [];
    var type = piece.toLowerCase();
    
    // Generate pseudo-legal moves (server will validate)
    if (type === 'p') {
        var dir = isWhite ? -1 : 1;
        var startRank = isWhite ? 6 : 1;
        
        // Forward
        if (!state.board[rank + dir] || !state.board[rank + dir][file]) {
            moves.push([file, rank + dir]);
            // Double push
            if (rank === startRank && (!state.board[rank + dir * 2] || !state.board[rank + dir * 2][file])) {
                moves.push([file, rank + dir * 2]);
            }
        }
        
        // Captures
        [-1, 1].forEach(function(df) {
            var nf = file + df;
            var nr = rank + dir;
            if (nf >= 0 && nf < 8 && nr >= 0 && nr < 8) {
                var target = state.board[nr][nf];
                if (target && (target === target.toUpperCase()) !== isWhite) {
                    moves.push([nf, nr]);
                }
                // En passant (simplified check)
                if (!target && (rank === 3 || rank === 4)) {
                    moves.push([nf, nr]);
                }
            }
        });
    } else if (type === 'n') {
        [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(function(pair) {
            var df = pair[0], dr = pair[1];
            var nf = file + df, nr = rank + dr;
            if (nf >= 0 && nf < 8 && nr >= 0 && nr < 8) {
                var target = state.board[nr][nf];
                if (!target || (target === target.toUpperCase()) !== isWhite) {
                    moves.push([nf, nr]);
                }
            }
        });
    } else if (type === 'k') {
        for (var dr = -1; dr <= 1; dr++) {
            for (var df = -1; df <= 1; df++) {
                if (dr === 0 && df === 0) continue;
                var nf = file + df, nr = rank + dr;
                if (nf >= 0 && nf < 8 && nr >= 0 && nr < 8) {
                    var target = state.board[nr][nf];
                    if (!target || (target === target.toUpperCase()) !== isWhite) {
                        moves.push([nf, nr]);
                    }
                }
            }
        }
        // Castling (simplified)
        if ((isWhite && rank === 7 && file === 4) || (!isWhite && rank === 0 && file === 4)) {
            moves.push([6, rank]); // Kingside
            moves.push([2, rank]); // Queenside
        }
    } else {
        // Sliding pieces (B, R, Q)
        var directions = [];
        if (type === 'b' || type === 'q') directions.push([-1,-1],[-1,1],[1,-1],[1,1]);
        if (type === 'r' || type === 'q') directions.push([-1,0],[1,0],[0,-1],[0,1]);
        
        directions.forEach(function(pair) {
            var df = pair[0], dr = pair[1];
            for (var i = 1; i < 8; i++) {
                var nf = file + df * i, nr = rank + dr * i;
                if (nf < 0 || nf >= 8 || nr < 0 || nr >= 8) break;
                var target = state.board[nr][nf];
                if (!target) {
                    moves.push([nf, nr]);
                } else {
                    if ((target === target.toUpperCase()) !== isWhite) {
                        moves.push([nf, nr]);
                    }
                    break;
                }
            }
        });
    }
    
    return moves.map(function(pair) {
        var f = pair[0], r = pair[1];
        return String.fromCharCode(97 + f) + (8 - r);
    });
}

// ============================================
// Board Rendering
// ============================================

function renderBoard() {
    var container = $('board');
    container.innerHTML = '';

    for (var r = 0; r < 8; r++) {
        for (var f = 0; f < 8; f++) {
            var rank = state.orientation === 'white' ? r : 7 - r;
            var file = state.orientation === 'white' ? f : 7 - f;
            var square = String.fromCharCode(97 + file) + (8 - rank);
            var piece = state.board[rank][file];

            var div = document.createElement('div');
            div.className = 'square ' + ((rank + file) % 2 === 0 ? 'light' : 'dark');
            div.dataset.square = square;

            // Highlights
            if (square === state.selectedSquare) {
                div.classList.add('selected');
            }
            if (state.legalMoves.includes(square)) {
                div.classList.add(state.board[rank][file] ? 'legal-capture' : 'legal-move');
            }
            
            // Piece
            if (piece) {
                var span = document.createElement('span');
                span.className = 'piece ' + (piece === piece.toUpperCase() ? 'white' : 'black');
                span.textContent = getPieceSymbol(piece);
                div.appendChild(span);
            }
            
            container.appendChild(div);
        }
    }
}

function getPieceSymbol(piece) {
    var symbols = {
        'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
        'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
    };
    return symbols[piece] || '';
}

// ============================================
// Move Handling
// ============================================

function handleSquareClick(square) {
    if (!state.currentGame || state.currentGame.status !== 'started') return;
    
    var file = square.charCodeAt(0) - 97;
    var rank = 8 - parseInt(square[1]);
    var piece = state.board[rank][file];
    
    // Check if it's my turn
    var movesLength = (state.currentGame && state.currentGame.moves) ? state.currentGame.moves.length : 0;
    var isWhiteTurn = (movesLength % 2) === 0;
    var isMyTurn = (state.orientation === 'white') === isWhiteTurn;
    
    if (!isMyTurn) return;
    
    if (state.selectedSquare) {
        // Second click - try to make move
        if (state.legalMoves.includes(square)) {
            makeMove(state.selectedSquare, square);
        } else if (piece) {
            // Select different piece
            var isWhite = piece === piece.toUpperCase();
            if ((state.orientation === 'white') === isWhite) {
                state.selectedSquare = square;
                state.legalMoves = getLegalMoves(square);
            } else {
                state.selectedSquare = null;
                state.legalMoves = [];
            }
        } else {
            state.selectedSquare = null;
            state.legalMoves = [];
        }
    } else {
        // First click - select piece
        if (piece) {
            var isWhite = piece === piece.toUpperCase();
            if ((state.orientation === 'white') === isWhite) {
                state.selectedSquare = square;
                state.legalMoves = getLegalMoves(square);
            }
        }
    }
    
    renderBoard();
}

function makeMove(from, to) {
    var fromFile = from.charCodeAt(0) - 97;
    var fromRank = 8 - parseInt(from[1]);
    var piece = state.board[fromRank][fromFile];
    
    // Check for promotion
    var toRank = 8 - parseInt(to[1]);
    var isPawn = piece.toLowerCase() === 'p';
    var isPromotion = isPawn && (toRank === 0 || toRank === 7);
    
    if (isPromotion) {
        state.pendingPromotion = { from: from, to: to };
        show('promotion-modal');
        return;
    }
    
    sendMove(from + to);
}

function selectPromotion(piece) {
    if (!state.pendingPromotion) return;
    
    var from = state.pendingPromotion.from;
    var to = state.pendingPromotion.to;
    hide('promotion-modal');
    sendMove(from + to + piece);
    state.pendingPromotion = null;
}

function sendMove(uci) {
    state.selectedSquare = null;
    state.legalMoves = [];
    renderBoard();

    fetchWithTimeout(
        CONFIG.LICHESS_HOST + '/api/board/game/' + state.currentGame.id + '/move/' + uci,
        {
            method: 'POST',
            headers: { 'Authorization': 'Bearer ' + state.token }
        },
        10000
    ).then(function(response) {
        if (!response.ok) {
            log('Move rejected');
            showError('Invalid move');
            // Move will be rejected, stream will update with correct state
        }
    }).catch(function(err) {
        log('Failed to send move:', err);
        showError('Failed to send move');
    });
}

// ============================================
// Game Actions
// ============================================

function resign() {
    if (!confirm('Are you sure you want to resign?')) return;

    fetchWithTimeout(
        CONFIG.LICHESS_HOST + '/api/board/game/' + state.currentGame.id + '/resign',
        {
            method: 'POST',
            headers: { 'Authorization': 'Bearer ' + state.token }
        },
        10000
    ).catch(function(err) {
        log('Failed to resign:', err);
        showError('Failed to resign');
    });
}

function offerDraw() {
    fetchWithTimeout(
        CONFIG.LICHESS_HOST + '/api/board/game/' + state.currentGame.id + '/draw/yes',
        {
            method: 'POST',
            headers: { 'Authorization': 'Bearer ' + state.token }
        },
        10000
    ).then(function() {
        alert('Draw offer sent');
    }).catch(function(err) {
        log('Failed to offer draw:', err);
        showError('Failed to offer draw');
    });
}

function backToLobby() {
    stopClockTimer();
    if (state.eventSource) {
        state.eventSource.close();
        state.eventSource = null;
    }
    showLobby();
}

function newGame() {
    stopClockTimer();
    if (state.eventSource) {
        state.eventSource.close();
        state.eventSource = null;
    }
    showLobby();
}

// ============================================
// Event Handlers Setup
// ============================================

function setupEventHandlers() {
    $('btn-login').onclick = startLogin;
    $('btn-logout').onclick = logout;
    $('btn-cancel-seek').onclick = cancelSeek;
    $('btn-back').onclick = backToLobby;
    $('btn-resign').onclick = resign;
    $('btn-draw').onclick = offerDraw;
    $('btn-new-game').onclick = newGame;
    $('btn-dismiss-error').onclick = dismissError;

    // Board click handler using event delegation
    $('board').onclick = function(e) {
        var target = e.target;
        // Find the square div (might have clicked on piece span)
        while (target && target.id !== 'board') {
            if (target.dataset && target.dataset.square) {
                handleSquareClick(target.dataset.square);
                return;
            }
            target = target.parentElement;
        }
    };

    // Promotion buttons
    document.querySelectorAll('.promo-btn').forEach(function(btn) {
        btn.onclick = function() {
            selectPromotion(btn.dataset.piece);
        };
    });
}

// ============================================
// Initialization
// ============================================

function checkBrowserCompatibility() {
    log('=== Browser Compatibility Check ===');
    log('User Agent:', navigator.userAgent);
    log('TextEncoder:', typeof TextEncoder !== 'undefined' ? 'OK' : 'MISSING (polyfilled)');
    log('TextDecoder:', typeof TextDecoder !== 'undefined' ? 'OK' : 'MISSING (polyfilled)');
    log('crypto.subtle:', window.crypto && window.crypto.subtle ? 'OK' : 'MISSING (polyfilled)');
    log('URLSearchParams:', typeof URLSearchParams !== 'undefined' ? 'OK' : 'MISSING (polyfilled)');
    log('fetch:', typeof fetch !== 'undefined' ? 'OK' : 'MISSING');
    log('Promise:', typeof Promise !== 'undefined' ? 'OK' : 'MISSING');
    log('localStorage:', typeof localStorage !== 'undefined' ? 'OK' : 'MISSING');
    log('ReadableStream:', typeof ReadableStream !== 'undefined' ? 'OK' : 'MISSING');
    log('===================================');
}

function init() {
    try {
        log('Initializing Lichess Kindle app...');

        // Check if polyfills loaded
        log('Polyfills check:');
        log('- window.POLYFILLS_LOADED = ' + (window.POLYFILLS_LOADED ? 'YES' : 'NO'));

        checkBrowserCompatibility();

        log('Setting up event handlers...');
        setupEventHandlers();
        log('Event handlers ready');

        // Show loading screen first
        log('Showing loading screen');
        showScreen('screen-loading');

        // Check for OAuth callback
        if (window.location.search.indexOf('code=') !== -1) {
            log('OAuth callback detected');
            handleOAuthCallback().then(function(success) {
                if (!success) {
                    showScreen('screen-login');
                    showError('Login failed. Please try again.');
                    return;
                }
                return checkAuth().then(function(authed) {
                    if (authed) {
                        showLobby();
                    } else {
                        showScreen('screen-login');
                        showError('Login failed. Please try again.');
                    }
                });
            }).catch(function(err) {
                log('CRITICAL: Init failed with error: ' + err.message);
                log('Error stack: ' + (err.stack || 'No stack trace'));
                showScreen('screen-login');
                showError('Initialization failed: ' + err.message);
            });
            return;
        }

        // Check existing auth
        log('Checking for existing auth...');
        checkAuth().then(function(authed) {
            if (authed) {
                log('Auth valid, showing lobby');
                showLobby();
            } else {
                log('No existing auth, showing login screen');
                showScreen('screen-login');
            }
        }).catch(function(err) {
            log('CRITICAL: Init failed with error: ' + err.message);
            log('Error stack: ' + (err.stack || 'No stack trace'));
            showScreen('screen-login');
            showError('Initialization failed: ' + err.message);
        });
    } catch (err) {
        log('CRITICAL: Init failed with error: ' + err.message);
        log('Error stack: ' + (err.stack || 'No stack trace'));
        showScreen('screen-login');
        showError('Initialization failed: ' + err.message);
    }
}

// Global error handler
window.addEventListener('error', function(e) {
    log('Global error: ' + e.message + ' at ' + e.filename + ':' + e.lineno);
});

window.addEventListener('unhandledrejection', function(e) {
    log('Unhandled promise rejection: ' + e.reason);
});

// Start app when DOM ready
log('=== APP LOADING ===');
log('DOM state: ' + document.readyState);

try {
    if (document.readyState === 'loading') {
        log('Waiting for DOM...');
        document.addEventListener('DOMContentLoaded', function() {
            log('DOM ready, starting init');
            try {
                init();
            } catch (err) {
                log('Init failed: ' + err.message);
                log('Stack: ' + err.stack);
            }
        });
    } else {
        log('DOM already ready, starting init');
        init();
    }
} catch (err) {
    log('Critical error during startup: ' + err.message);
    log('Stack: ' + err.stack);
}

</script>
</body>
</html>
