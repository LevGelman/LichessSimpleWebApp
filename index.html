<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="color-scheme" content="light">
    <title>Lichess - Kindle</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="app">
        <!-- Loading Screen -->
        <div id="screen-loading" class="screen">
            <h1>♔ Lichess</h1>
            <p class="subtitle">Loading...</p>
            <div id="debug-log" class="debug-log"></div>
        </div>

        <!-- Error Display -->
        <div id="error-banner" class="error-banner hidden">
            <span id="error-message"></span>
            <button id="btn-dismiss-error" class="btn btn-small">×</button>
        </div>

        <!-- Login Screen -->
        <div id="screen-login" class="screen hidden">
            <h1>♔ Lichess</h1>
            <p class="subtitle">Kindle Edition</p>
            <button id="btn-login" class="btn btn-large">Login with Lichess</button>
            <p class="help-text">You'll be redirected to Lichess to authorize this app.</p>
        </div>

        <!-- Lobby Screen -->
        <div id="screen-lobby" class="screen hidden">
            <header>
                <span id="username">Player</span>
                <button id="btn-logout" class="btn btn-small">Logout</button>
            </header>

            <h2>New Game</h2>

            <div id="time-controls">
                <!-- Time control buttons generated by JS -->
            </div>

            <div id="seeking" class="hidden">
                <p>Seeking opponent...</p>
                <button id="btn-cancel-seek" class="btn">Cancel</button>
            </div>

            <div id="ongoing-games" class="hidden">
                <h3>Ongoing Games</h3>
                <div id="games-list"></div>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="screen-game" class="screen hidden">
            <header class="game-header">
                <button id="btn-back" class="btn btn-small">← Back</button>
                <span id="game-status">Playing</span>
            </header>

            <div class="player-info opponent">
                <span id="opponent-name">Opponent</span>
                <span id="opponent-clock" class="clock">--:--</span>
            </div>

            <div id="board">
                <!-- 8x8 board generated by JS -->
            </div>

            <div class="player-info player">
                <span id="player-name">You</span>
                <span id="player-clock" class="clock">--:--</span>
            </div>

            <div id="game-controls">
                <button id="btn-resign" class="btn">Resign</button>
                <button id="btn-draw" class="btn">Offer Draw</button>
            </div>

            <div id="game-result" class="hidden">
                <p id="result-text"></p>
                <button id="btn-new-game" class="btn btn-large">New Game</button>
            </div>

            <div id="promotion-modal" class="modal hidden">
                <div class="modal-content">
                    <p>Promote to:</p>
                    <div class="promotion-pieces">
                        <button class="promo-btn" data-piece="q">♛</button>
                        <button class="promo-btn" data-piece="r">♜</button>
                        <button class="promo-btn" data-piece="b">♝</button>
                        <button class="promo-btn" data-piece="n">♞</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ALL CODE INLINE -->
    <script>
// Polyfills for Kindle Browser Compatibility
// These provide fallbacks for missing modern browser APIs

(function() {
    'use strict';

    // ============================================
    // TextEncoder / TextDecoder Polyfills
    // ============================================

    if (typeof TextEncoder === 'undefined') {
        window.TextEncoder = function TextEncoder() {};
        TextEncoder.prototype.encode = function encode(str) {
            var utf8 = [];
            for (var i = 0; i < str.length; i++) {
                var charcode = str.charCodeAt(i);
                if (charcode < 0x80) {
                    utf8.push(charcode);
                } else if (charcode < 0x800) {
                    utf8.push(0xc0 | (charcode >> 6),
                              0x80 | (charcode & 0x3f));
                } else if (charcode < 0xd800 || charcode >= 0xe000) {
                    utf8.push(0xe0 | (charcode >> 12),
                              0x80 | ((charcode >> 6) & 0x3f),
                              0x80 | (charcode & 0x3f));
                } else {
                    i++;
                    charcode = 0x10000 + (((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
                    utf8.push(0xf0 | (charcode >> 18),
                              0x80 | ((charcode >> 12) & 0x3f),
                              0x80 | ((charcode >> 6) & 0x3f),
                              0x80 | (charcode & 0x3f));
                }
            }
            return new Uint8Array(utf8);
        };
    }

    if (typeof TextDecoder === 'undefined') {
        window.TextDecoder = function TextDecoder() {};
        TextDecoder.prototype.decode = function decode(bytes) {
            var str = '';
            var i = 0;
            while (i < bytes.length) {
                var byte1 = bytes[i];
                if (byte1 < 0x80) {
                    str += String.fromCharCode(byte1);
                    i++;
                } else if (byte1 >= 0xc0 && byte1 < 0xe0) {
                    var byte2 = bytes[i + 1];
                    str += String.fromCharCode(((byte1 & 0x1f) << 6) | (byte2 & 0x3f));
                    i += 2;
                } else if (byte1 >= 0xe0 && byte1 < 0xf0) {
                    var byte2 = bytes[i + 1];
                    var byte3 = bytes[i + 2];
                    str += String.fromCharCode(((byte1 & 0x0f) << 12) | ((byte2 & 0x3f) << 6) | (byte3 & 0x3f));
                    i += 3;
                } else {
                    var byte2 = bytes[i + 1];
                    var byte3 = bytes[i + 2];
                    var byte4 = bytes[i + 3];
                    var codepoint = ((byte1 & 0x07) << 18) | ((byte2 & 0x3f) << 12) | ((byte3 & 0x3f) << 6) | (byte4 & 0x3f);
                    codepoint -= 0x10000;
                    str += String.fromCharCode((codepoint >> 10) + 0xd800, (codepoint & 0x3ff) + 0xdc00);
                    i += 4;
                }
            }
            return str;
        };
    }

    // ============================================
    // Crypto Polyfill for SHA-256
    // ============================================

    // Check if crypto.subtle.digest exists
    if (!window.crypto || !window.crypto.subtle || !window.crypto.subtle.digest) {
        console.warn('crypto.subtle.digest not available, using fallback SHA-256');

        // Simplified SHA-256 implementation
        // Based on https://github.com/emn178/js-sha256
        function sha256Hash(bytes) {
            var h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;
            var h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;
            var w = [];
            var a, b, c, d, e, f, g, h, i, j, t1, t2;
            var k = [
                0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
                0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
                0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
                0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
                0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
                0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
            ];

            // Padding
            var msgLen = bytes.length;
            var bitLen = msgLen * 8;
            var paddedLen = ((msgLen + 8) >> 6 << 4) + 16;
            var blocks = new Uint32Array(paddedLen);

            // Copy bytes to blocks
            for (i = 0; i < msgLen; i++) {
                blocks[i >> 2] |= bytes[i] << (24 - (i % 4) * 8);
            }

            // Append 1 bit and length
            blocks[msgLen >> 2] |= 0x80 << (24 - (msgLen % 4) * 8);
            blocks[paddedLen - 1] = bitLen;
            blocks[paddedLen - 2] = (bitLen / 0x100000000) | 0;

            // Process blocks
            for (i = 0; i < paddedLen; i += 16) {
                a = h0; b = h1; c = h2; d = h3;
                e = h4; f = h5; g = h6; h = h7;

                for (j = 0; j < 64; j++) {
                    if (j < 16) {
                        w[j] = blocks[i + j];
                    } else {
                        var s0 = rightRotate(w[j - 15], 7) ^ rightRotate(w[j - 15], 18) ^ (w[j - 15] >>> 3);
                        var s1 = rightRotate(w[j - 2], 17) ^ rightRotate(w[j - 2], 19) ^ (w[j - 2] >>> 10);
                        w[j] = (w[j - 16] + s0 + w[j - 7] + s1) | 0;
                    }

                    var S1 = rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25);
                    var ch = (e & f) ^ (~e & g);
                    t1 = (h + S1 + ch + k[j] + w[j]) | 0;
                    var S0 = rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22);
                    var maj = (a & b) ^ (a & c) ^ (b & c);
                    t2 = (S0 + maj) | 0;

                    h = g; g = f; f = e;
                    e = (d + t1) | 0;
                    d = c; c = b; b = a;
                    a = (t1 + t2) | 0;
                }

                h0 = (h0 + a) | 0; h1 = (h1 + b) | 0;
                h2 = (h2 + c) | 0; h3 = (h3 + d) | 0;
                h4 = (h4 + e) | 0; h5 = (h5 + f) | 0;
                h6 = (h6 + g) | 0; h7 = (h7 + h) | 0;
            }

            // Return hash as ArrayBuffer
            var hash = new Uint8Array(32);
            hash[0] = (h0 >>> 24) & 0xff; hash[1] = (h0 >>> 16) & 0xff;
            hash[2] = (h0 >>> 8) & 0xff;  hash[3] = h0 & 0xff;
            hash[4] = (h1 >>> 24) & 0xff; hash[5] = (h1 >>> 16) & 0xff;
            hash[6] = (h1 >>> 8) & 0xff;  hash[7] = h1 & 0xff;
            hash[8] = (h2 >>> 24) & 0xff; hash[9] = (h2 >>> 16) & 0xff;
            hash[10] = (h2 >>> 8) & 0xff; hash[11] = h2 & 0xff;
            hash[12] = (h3 >>> 24) & 0xff; hash[13] = (h3 >>> 16) & 0xff;
            hash[14] = (h3 >>> 8) & 0xff;  hash[15] = h3 & 0xff;
            hash[16] = (h4 >>> 24) & 0xff; hash[17] = (h4 >>> 16) & 0xff;
            hash[18] = (h4 >>> 8) & 0xff;  hash[19] = h4 & 0xff;
            hash[20] = (h5 >>> 24) & 0xff; hash[21] = (h5 >>> 16) & 0xff;
            hash[22] = (h5 >>> 8) & 0xff;  hash[23] = h5 & 0xff;
            hash[24] = (h6 >>> 24) & 0xff; hash[25] = (h6 >>> 16) & 0xff;
            hash[26] = (h6 >>> 8) & 0xff;  hash[27] = h6 & 0xff;
            hash[28] = (h7 >>> 24) & 0xff; hash[29] = (h7 >>> 16) & 0xff;
            hash[30] = (h7 >>> 8) & 0xff;  hash[31] = h7 & 0xff;

            return hash.buffer;
        }

        function rightRotate(n, b) {
            return (n >>> b) | (n << (32 - b));
        }

        // Create polyfill
        if (!window.crypto) {
            window.crypto = {};
        }
        if (!window.crypto.subtle) {
            window.crypto.subtle = {};
        }

        window.crypto.subtle.digest = function(algorithm, data) {
            return new Promise(function(resolve, reject) {
                try {
                    if (algorithm === 'SHA-256') {
                        var bytes = new Uint8Array(data);
                        var hash = sha256Hash(bytes);
                        resolve(hash);
                    } else {
                        reject(new Error('Unsupported algorithm: ' + algorithm));
                    }
                } catch (e) {
                    reject(e);
                }
            });
        };
    }

    // ============================================
    // URLSearchParams Polyfill
    // ============================================

    if (typeof URLSearchParams === 'undefined' || !URLSearchParams.prototype.toString) {
        window.URLSearchParams = function(init) {
            this.params = {};

            if (typeof init === 'string') {
                var pairs = init.replace(/^\?/, '').split('&');
                for (var i = 0; i < pairs.length; i++) {
                    var pair = pairs[i].split('=');
                    if (pair[0]) {
                        this.params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
                    }
                }
            } else if (typeof init === 'object') {
                for (var key in init) {
                    if (init.hasOwnProperty(key)) {
                        this.params[key] = init[key];
                    }
                }
            }
        };

        URLSearchParams.prototype.get = function(name) {
            return this.params[name] || null;
        };

        URLSearchParams.prototype.set = function(name, value) {
            this.params[name] = String(value);
        };

        URLSearchParams.prototype.toString = function() {
            var parts = [];
            for (var key in this.params) {
                if (this.params.hasOwnProperty(key)) {
                    parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(this.params[key]));
                }
            }
            return parts.join('&');
        };
    }

    // ============================================
    // Promise.prototype.finally Polyfill
    // ============================================

    if (typeof Promise !== 'undefined' && !Promise.prototype.finally) {
        Promise.prototype.finally = function(callback) {
            var P = this.constructor;
            return this.then(
                function(value) {
                    return P.resolve(callback()).then(function() { return value; });
                },
                function(reason) {
                    return P.resolve(callback()).then(function() { throw reason; });
                }
            );
        };
    }

    // Mark that polyfills loaded
    window.POLYFILLS_LOADED = true;

    // Try to log (console might not be overridden yet)
    if (window.console && window.console.log) {
        window.console.log('✓ Polyfills loaded successfully');
    }
})();
// Lichess OAuth Configuration
// 
// IMPORTANT: Lichess uses UNREGISTERED/PUBLIC clients!
// You do NOT need to register an app. Just pick a unique client ID.
// 
// HOW IT WORKS:
// 1. Choose a unique client_id for your app (e.g., 'kindle-chess-yourname')
// 2. That's it! No registration, no client secret needed.
// 3. Users will be redirected to Lichess to authorize your app
//
// See: https://lichess.org/api#tag/OAuth
// "Lichess supports unregistered and public clients (no client authentication, 
//  choose any unique client id)"

const CONFIG = {
    // Choose a unique client ID for your app
    // Convention: lowercase, use hyphens, make it descriptive and unique
    // Examples: 'kindle-chess-lev', 'my-chess-app-2024', 'chess-viewer-mobile'
    LICHESS_CLIENT_ID: 'kindle-lichess-client',
    
    // Redirect URI - auto-detects from current URL
    // For local testing: http://localhost:4280/
    // For Azure: https://your-app.azurestaticapps.net/
    REDIRECT_URI: window.location.origin + '/',
    
    // Lichess API endpoints
    LICHESS_HOST: 'https://lichess.org',
    
    // OAuth endpoints (for reference)
    // Authorization: https://lichess.org/oauth
    // Token exchange: https://lichess.org/api/token
    
    // Available time controls (in minutes + increment in seconds)
    TIME_CONTROLS: [
        { name: '10+0 Rapid', time: 10, increment: 0 },
        { name: '10+5 Rapid', time: 10, increment: 5 },
        { name: '15+10 Rapid', time: 15, increment: 10 },
        { name: '30+0 Classical', time: 30, increment: 0 }
    ],
    
    // UI Settings optimized for Kindle
    SETTINGS: {
        // Show coordinates on board edge
        showCoordinates: false,
        // Confirm moves before sending (adds extra tap)
        confirmMoves: false,
        // Low time warning threshold (seconds)
        lowTimeThreshold: 30
    }
};
// Lichess Kindle Client - Main Application
// No dependencies, vanilla JS

// Log immediately to catch early errors
if (window.console && window.console.log) {
    window.console.log('>>> app.js loading...');
}

// ============================================
// On-Screen Debug Logger for Kindle
// ============================================

const debugLines = [];
const MAX_DEBUG_LINES = 50;

function debugLog(message, isError) {
    // Add to array
    const timestamp = new Date().toLocaleTimeString();
    debugLines.push({
        time: timestamp,
        msg: String(message),
        isError: isError
    });

    // Keep only last N lines
    if (debugLines.length > MAX_DEBUG_LINES) {
        debugLines.shift();
    }

    // Update display
    updateDebugDisplay();

    // Also log to console (if available)
    if (isError) {
        console.error(message);
    } else {
        console.log(message);
    }
}

function updateDebugDisplay() {
    const debugEl = document.getElementById('debug-log');
    if (!debugEl) return;

    let html = '';
    for (let i = 0; i < debugLines.length; i++) {
        const line = debugLines[i];
        const className = line.isError ? 'debug-error' : 'debug-ok';
        html += '<div class="debug-line ' + className + '">' +
                line.time + ' ' + line.msg + '</div>';
    }
    debugEl.innerHTML = html;

    // Auto-scroll to bottom
    debugEl.scrollTop = debugEl.scrollHeight;
}

// Override console methods to show on screen
const originalConsoleLog = console.log;
const originalConsoleError = console.error;
const originalConsoleWarn = console.warn;

console.log = function() {
    const message = Array.prototype.slice.call(arguments).join(' ');
    debugLog(message, false);
};

console.error = function() {
    const message = Array.prototype.slice.call(arguments).join(' ');
    debugLog(message, true);
};

console.warn = function() {
    const message = 'WARN: ' + Array.prototype.slice.call(arguments).join(' ');
    debugLog(message, false);
};

// ============================================
// State
// ============================================

const state = {
    token: null,
    user: null,
    currentGame: null,
    board: null,
    selectedSquare: null,
    legalMoves: [],
    orientation: 'white',
    pendingPromotion: null,
    eventSource: null,
    seekEventSource: null,
    seekReader: null,
    eventStreamReader: null,
    clockInterval: null,
    lastClockUpdate: null,
    whiteTime: null,
    blackTime: null,
    isWhiteTurn: true
};

// ============================================
// Utility Functions
// ============================================

function $(id) {
    return document.getElementById(id);
}

function show(id) {
    $(id).classList.remove('hidden');
}

function hide(id) {
    $(id).classList.add('hidden');
}

function showScreen(screenId) {
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    $(screenId).classList.remove('hidden');
}

function showError(message) {
    $('error-message').textContent = message;
    show('error-banner');
    
    // Auto-hide after 5 seconds
    setTimeout(function() {
        hide('error-banner');
    }, 5000);
}

function dismissError() {
    hide('error-banner');
}

// Generate random string for OAuth PKCE
function generateRandomString(length) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    const values = new Uint8Array(length);
    window.crypto.getRandomValues(values);
    for (let i = 0; i < length; i++) {
        result += chars[values[i] % chars.length];
    }
    return result;
}

// SHA256 hash for PKCE
async function sha256(plain) {
    const encoder = new TextEncoder();
    const data = encoder.encode(plain);
    const hash = await window.crypto.subtle.digest('SHA-256', data);
    return hash;
}

// Base64 URL encode
function base64UrlEncode(arrayBuffer) {
    const bytes = new Uint8Array(arrayBuffer);
    let binary = '';
    for (let i = 0; i < bytes.length; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary)
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
}

// Format time for clock display
function formatTime(seconds) {
    if (seconds === undefined || seconds === null) return '--:--';
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return mins + ':' + (secs < 10 ? '0' : '') + secs;
}

// Fetch with timeout for Kindle compatibility
function fetchWithTimeout(url, options, timeout) {
    timeout = timeout || 30000; // 30 second default

    return new Promise(function(resolve, reject) {
        var timedOut = false;
        var timer = setTimeout(function() {
            timedOut = true;
            reject(new Error('Request timeout'));
        }, timeout);

        fetch(url, options)
            .then(function(response) {
                clearTimeout(timer);
                if (!timedOut) {
                    resolve(response);
                }
            })
            .catch(function(error) {
                clearTimeout(timer);
                if (!timedOut) {
                    reject(error);
                }
            });
    });
}

// ============================================
// OAuth Authentication
// ============================================

async function startLogin() {
    try {
        console.log('Starting login...');
        const codeVerifier = generateRandomString(64);
        localStorage.setItem('pkce_verifier', codeVerifier);

        console.log('Hashing code verifier...');
        const hashed = await sha256(codeVerifier);
        const codeChallenge = base64UrlEncode(hashed);
        console.log('Hash complete');

        const params = new URLSearchParams({
            response_type: 'code',
            client_id: CONFIG.LICHESS_CLIENT_ID,
            redirect_uri: CONFIG.REDIRECT_URI,
            scope: 'board:play',
            code_challenge_method: 'S256',
            code_challenge: codeChallenge
        });

        window.location.href = CONFIG.LICHESS_HOST + '/oauth?' + params.toString();
    } catch (err) {
        console.error('Login failed:', err);
        showError('Login failed: ' + err.message);
        showScreen('screen-login');
    }
}

async function handleOAuthCallback() {
    const params = new URLSearchParams(window.location.search);
    const code = params.get('code');
    
    if (!code) return false;
    
    const codeVerifier = localStorage.getItem('pkce_verifier');
    if (!codeVerifier) {
        console.error('No code verifier found');
        return false;
    }
    
    try {
        console.log('Exchanging OAuth code for token...');
        const response = await fetchWithTimeout(CONFIG.LICHESS_HOST + '/api/token', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: new URLSearchParams({
                grant_type: 'authorization_code',
                code: code,
                code_verifier: codeVerifier,
                redirect_uri: CONFIG.REDIRECT_URI,
                client_id: CONFIG.LICHESS_CLIENT_ID
            }).toString()
        }, 30000);

        if (!response.ok) {
            console.error('Token exchange failed with status:', response.status);
            throw new Error('Token exchange failed');
        }

        const data = await response.json();
        state.token = data.access_token;
        localStorage.setItem('lichess_token', state.token);
        localStorage.removeItem('pkce_verifier');

        console.log('OAuth success');
        // Clean URL
        window.history.replaceState({}, document.title, '/');

        return true;
    } catch (err) {
        console.error('OAuth error:', err);
        showError('OAuth failed: ' + err.message);
        return false;
    }
}

async function checkAuth() {
    state.token = localStorage.getItem('lichess_token');
    if (!state.token) return false;

    try {
        console.log('Checking authentication...');
        const response = await fetchWithTimeout(CONFIG.LICHESS_HOST + '/api/account', {
            headers: { 'Authorization': 'Bearer ' + state.token }
        }, 20000);

        if (!response.ok) {
            console.log('Auth check failed, clearing token');
            localStorage.removeItem('lichess_token');
            state.token = null;
            return false;
        }

        state.user = await response.json();
        console.log('Authenticated as:', state.user.username);
        return true;
    } catch (err) {
        console.error('Auth check failed:', err);
        showError('Connection failed: ' + err.message);
        localStorage.removeItem('lichess_token');
        state.token = null;
        return false;
    }
}

function logout() {
    localStorage.removeItem('lichess_token');
    state.token = null;
    state.user = null;
    if (state.eventSource) state.eventSource.close();
    if (state.seekEventSource) state.seekEventSource.close();
    stopEventStream();
    showScreen('screen-login');
}

// ============================================
// Lobby & Game Seeking
// ============================================

function showLobby() {
    $('username').textContent = state.user.username;
    renderTimeControls();
    showScreen('screen-lobby');
    checkOngoingGames();
}

function renderTimeControls() {
    const container = $('time-controls');
    container.innerHTML = '';
    
    CONFIG.TIME_CONTROLS.forEach(tc => {
        const btn = document.createElement('button');
        btn.className = 'btn time-btn';
        btn.textContent = tc.name;
        btn.onclick = () => seekGame(tc.time, tc.increment);
        container.appendChild(btn);
    });
}

async function checkOngoingGames() {
    try {
        const response = await fetchWithTimeout(CONFIG.LICHESS_HOST + '/api/account/playing', {
            headers: { 'Authorization': 'Bearer ' + state.token }
        }, 15000);

        if (!response.ok) return;

        const data = await response.json();
        const games = data.nowPlaying || [];

        if (games.length > 0) {
            show('ongoing-games');
            const list = $('games-list');
            list.innerHTML = '';

            games.forEach(game => {
                const div = document.createElement('div');
                div.className = 'game-item';
                div.innerHTML =
                    '<span>vs ' + game.opponent.username + '</span>' +
                    '<button class="btn btn-small">Resume</button>';
                div.querySelector('button').onclick = () => joinGame(game.gameId);
                list.appendChild(div);
            });
        } else {
            hide('ongoing-games');
        }
    } catch (err) {
        console.error('Failed to check ongoing games:', err);
    }
}

async function seekGame(minutes, increment) {
    show('seeking');
    
    // First, start listening to the event stream to catch game start
    startEventStream();
    
    try {
        // Create the seek - this will stream until cancelled or game found
        const response = await fetchWithTimeout(CONFIG.LICHESS_HOST + '/api/board/seek', {
            method: 'POST',
            headers: {
                'Authorization': 'Bearer ' + state.token,
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: new URLSearchParams({
                time: minutes,
                increment: increment,
                rated: 'true',
                variant: 'standard',
                color: 'random'
            }).toString()
        }, 120000);
        
        if (!response.ok) {
            let errorMsg = 'Seek failed: ' + response.status;
            try {
                const errorBody = await response.text();
                console.error('Seek error body:', errorBody);
                errorMsg += ' - ' + errorBody;
            } catch (e) {}
            throw new Error(errorMsg);
        }
        
        // The seek stream stays open while waiting for an opponent
        // Game start notification comes via the event stream
        // Keep reading to keep the seek alive
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        
        state.seekReader = reader;
        
        while (true) {
            const { value, done } = await reader.read();
            if (done) {
                console.log('Seek stream ended');
                break;
            }
            
            const text = decoder.decode(value);
            console.log('Seek stream data:', text);
            
            // Sometimes the game ID comes directly in the seek response
            const lines = text.split('\n').filter(l => l.trim());
            for (const line of lines) {
                try {
                    const event = JSON.parse(line);
                    console.log('Seek event:', event);
                    if (event.id) {
                        hide('seeking');
                        joinGame(event.id);
                        return;
                    }
                } catch (e) {}
            }
        }
        
        // Stream ended without finding game
        hide('seeking');
        showError('No opponent found. Try again.');
        
    } catch (err) {
        console.error('Seek error:', err);
        hide('seeking');
        if (err.name !== 'AbortError') {
            showError('Failed to find game. Please try again.');
        }
    }
}

// Event stream to receive game start notifications
function startEventStream() {
    if (state.eventStreamReader) {
        return; // Already listening
    }

    console.log('Starting event stream...');

    fetch(CONFIG.LICHESS_HOST + '/api/stream/event', {
        headers: { 'Authorization': 'Bearer ' + state.token }
    }).then(function(response) {
        if (!response.ok) {
            console.error('Event stream failed:', response.status);
            return;
        }

        var reader = response.body.getReader();
        var decoder = new TextDecoder();
        state.eventStreamReader = reader;

        // Iterative reading to avoid stack overflow on Kindle
        function readChunk() {
            reader.read().then(function(result) {
                if (result.done) {
                    console.log('Event stream ended');
                    state.eventStreamReader = null;
                    return;
                }

                try {
                    var text = decoder.decode(result.value, { stream: true });
                    var lines = text.split('\n');

                    for (var i = 0; i < lines.length; i++) {
                        var line = lines[i].trim();
                        if (line) {
                            try {
                                var event = JSON.parse(line);
                                console.log('Event:', event);
                                handleIncomingEvent(event);
                            } catch (e) {
                                console.log('Failed to parse event line:', e);
                            }
                        }
                    }
                } catch (e) {
                    console.error('Failed to decode stream:', e);
                }

                // Continue reading (async, no recursion)
                setTimeout(readChunk, 0);
            }).catch(function(err) {
                console.error('Event stream error:', err);
                state.eventStreamReader = null;
            });
        }

        readChunk();
    }).catch(function(err) {
        console.error('Failed to start event stream:', err);
    });
}

function handleIncomingEvent(event) {
    if (event.type === 'gameStart') {
        console.log('Game started!', event.game);
        hide('seeking');
        
        // Cancel the seek stream
        if (state.seekReader) {
            state.seekReader.cancel();
            state.seekReader = null;
        }
        
        joinGame(event.game.gameId || event.game.id);
    } else if (event.type === 'gameFinish') {
        console.log('Game finished', event.game);
        checkOngoingGames();
    } else if (event.type === 'challenge') {
        console.log('Challenge received', event.challenge);
        // Could show challenge notification here
    }
}

function stopEventStream() {
    if (state.eventStreamReader) {
        state.eventStreamReader.cancel();
        state.eventStreamReader = null;
    }
}

function cancelSeek() {
    // Cancel the seek stream
    if (state.seekReader) {
        state.seekReader.cancel();
        state.seekReader = null;
    }
    if (state.seekEventSource) {
        state.seekEventSource.close();
        state.seekEventSource = null;
    }
    hide('seeking');
}

// ============================================
// Game Logic
// ============================================

async function joinGame(gameId) {
    state.currentGame = { id: gameId };
    state.board = null;
    state.selectedSquare = null;
    state.legalMoves = [];
    
    showScreen('screen-game');
    hide('game-result');
    show('game-controls');
    $('game-status').textContent = 'Connecting...';
    
    // Stream game events
    streamGame(gameId);
}

function streamGame(gameId) {
    if (state.eventSource) {
        state.eventSource.close();
    }

    console.log('Streaming game:', gameId);

    // Use fetch with streaming for better Kindle compatibility
    fetch(CONFIG.LICHESS_HOST + '/api/board/game/stream/' + gameId, {
        headers: { 'Authorization': 'Bearer ' + state.token }
    }).then(function(response) {
        if (!response.ok) {
            console.error('Game stream failed:', response.status);
            $('game-status').textContent = 'Connection failed';
            return;
        }

        var reader = response.body.getReader();
        var decoder = new TextDecoder();
        var buffer = '';

        // Iterative reading to avoid stack overflow on Kindle
        function readChunk() {
            reader.read().then(function(result) {
                if (result.done) {
                    console.log('Game stream ended');
                    return;
                }

                try {
                    buffer += decoder.decode(result.value, { stream: true });
                    var lines = buffer.split('\n');

                    // Keep last incomplete line in buffer
                    buffer = lines.pop() || '';

                    for (var i = 0; i < lines.length; i++) {
                        var line = lines[i].trim();
                        if (line) {
                            try {
                                var event = JSON.parse(line);
                                handleGameEvent(event);
                            } catch (e) {
                                console.log('Failed to parse game event:', e);
                            }
                        }
                    }
                } catch (e) {
                    console.error('Failed to decode game stream:', e);
                }

                // Continue reading (async, no recursion)
                setTimeout(readChunk, 0);
            }).catch(function(err) {
                console.error('Game stream error:', err);
                $('game-status').textContent = 'Connection lost';
            });
        }

        readChunk();
    }).catch(function(err) {
        console.error('Failed to stream game:', err);
        $('game-status').textContent = 'Connection failed';
        showError('Failed to connect to game');
    });
}

function handleGameEvent(event) {
    if (event.type === 'gameFull') {
        // Initial game state
        state.currentGame = {
            ...state.currentGame,
            white: event.white,
            black: event.black,
            initialFen: event.initialFen || 'startpos'
        };
        
        // Determine orientation
        state.orientation = (event.white.id === state.user.id.toLowerCase()) ? 'white' : 'black';
        
        // Set player names
        if (state.orientation === 'white') {
            $('player-name').textContent = event.white.name || event.white.id;
            $('opponent-name').textContent = event.black.name || event.black.id;
        } else {
            $('player-name').textContent = event.black.name || event.black.id;
            $('opponent-name').textContent = event.white.name || event.white.id;
        }
        
        handleGameState(event.state);
        
    } else if (event.type === 'gameState') {
        handleGameState(event);
        
    } else if (event.type === 'chatLine') {
        // Ignore chat
    }
}

function handleGameState(gameState) {
    // Parse moves and build position
    const moves = gameState.moves ? gameState.moves.split(' ').filter(m => m) : [];
    state.board = buildPosition(moves);
    state.currentGame.moves = moves;
    state.currentGame.status = gameState.status;
    state.currentGame.winner = gameState.winner;
    
    // Calculate whose turn
    state.isWhiteTurn = moves.length % 2 === 0;
    const isMyTurn = (state.orientation === 'white') === state.isWhiteTurn;
    
    // Update clocks
    updateClocks(gameState.wtime, gameState.btime);
    
    // Update status
    if (gameState.status === 'started' || gameState.status === 'created') {
        $('game-status').textContent = isMyTurn ? 'Your turn' : "Opponent's turn";
    } else {
        stopClockTimer();
        showGameResult(gameState);
    }
    
    // Clear selection
    state.selectedSquare = null;
    state.legalMoves = [];
    
    renderBoard();
}

function updateClocks(wtime, btime) {
    state.whiteTime = Math.floor((wtime || 0) / 1000);
    state.blackTime = Math.floor((btime || 0) / 1000);
    state.lastClockUpdate = Date.now();
    
    renderClocks();
    startClockTimer();
}

function renderClocks() {
    let playerTime, opponentTime;
    if (state.orientation === 'white') {
        playerTime = state.whiteTime;
        opponentTime = state.blackTime;
    } else {
        playerTime = state.blackTime;
        opponentTime = state.whiteTime;
    }
    
    const playerClock = $('player-clock');
    const opponentClock = $('opponent-clock');
    
    playerClock.textContent = formatTime(Math.max(0, playerTime));
    opponentClock.textContent = formatTime(Math.max(0, opponentTime));
    
    const threshold = CONFIG.SETTINGS?.lowTimeThreshold || 30;
    playerClock.classList.toggle('low-time', playerTime < threshold);
    opponentClock.classList.toggle('low-time', opponentTime < threshold);
}

function startClockTimer() {
    // Clear existing timer
    if (state.clockInterval) {
        clearInterval(state.clockInterval);
    }
    
    // Only run timer during active game
    if (!state.currentGame || state.currentGame.status !== 'started') {
        return;
    }
    
    // Update clock every second
    state.clockInterval = setInterval(function() {
        if (!state.lastClockUpdate) return;
        
        const elapsed = Math.floor((Date.now() - state.lastClockUpdate) / 1000);
        
        if (state.isWhiteTurn) {
            state.whiteTime = Math.max(0, state.whiteTime - elapsed);
        } else {
            state.blackTime = Math.max(0, state.blackTime - elapsed);
        }
        
        state.lastClockUpdate = Date.now();
        renderClocks();
    }, 1000);
}

function stopClockTimer() {
    if (state.clockInterval) {
        clearInterval(state.clockInterval);
        state.clockInterval = null;
    }
}

function showGameResult(gameState) {
    hide('game-controls');
    show('game-result');
    
    let resultText = '';
    const status = gameState.status;
    const winner = gameState.winner;
    
    if (status === 'draw' || status === 'stalemate') {
        resultText = 'Draw';
    } else if (status === 'mate') {
        resultText = winner === state.orientation ? 'You won by checkmate!' : 'You lost by checkmate';
    } else if (status === 'resign') {
        resultText = winner === state.orientation ? 'Opponent resigned - You win!' : 'You resigned';
    } else if (status === 'timeout') {
        resultText = winner === state.orientation ? 'Opponent ran out of time - You win!' : 'You ran out of time';
    } else if (status === 'outoftime') {
        resultText = winner === state.orientation ? 'You win on time!' : 'You lost on time';
    } else {
        resultText = 'Game over: ' + status;
    }
    
    $('result-text').textContent = resultText;
    $('game-status').textContent = 'Game Over';
}

// ============================================
// Board Position & Move Generation
// ============================================

function buildPosition(moves) {
    // Start from initial position
    const board = [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
    ];
    
    // Apply each move
    for (const move of moves) {
        applyMove(board, move);
    }
    
    return board;
}

function applyMove(board, uci) {
    const fromFile = uci.charCodeAt(0) - 97;
    const fromRank = 8 - parseInt(uci[1]);
    const toFile = uci.charCodeAt(2) - 97;
    const toRank = 8 - parseInt(uci[3]);
    const promotion = uci[4];
    
    const piece = board[fromRank][fromFile];
    
    // Handle castling
    if (piece.toLowerCase() === 'k' && Math.abs(fromFile - toFile) === 2) {
        // Move king
        board[toRank][toFile] = piece;
        board[fromRank][fromFile] = '';
        
        // Move rook
        if (toFile > fromFile) {
            // Kingside
            board[toRank][5] = board[toRank][7];
            board[toRank][7] = '';
        } else {
            // Queenside
            board[toRank][3] = board[toRank][0];
            board[toRank][0] = '';
        }
        return;
    }
    
    // Handle en passant
    if (piece.toLowerCase() === 'p' && fromFile !== toFile && !board[toRank][toFile]) {
        board[fromRank][toFile] = '';
    }
    
    // Regular move
    board[toRank][toFile] = piece;
    board[fromRank][fromFile] = '';
    
    // Handle promotion
    if (promotion) {
        const isWhite = piece === 'P';
        board[toRank][toFile] = isWhite ? promotion.toUpperCase() : promotion.toLowerCase();
    }
}

function getLegalMoves(square) {
    // Simplified move generation - server validates anyway
    const file = square.charCodeAt(0) - 97;
    const rank = 8 - parseInt(square[1]);
    const piece = state.board[rank][file];
    
    if (!piece) return [];
    
    const isWhite = piece === piece.toUpperCase();
    const isMyPiece = (state.orientation === 'white') === isWhite;
    
    if (!isMyPiece) return [];
    
    const moves = [];
    const type = piece.toLowerCase();
    
    // Generate pseudo-legal moves (server will validate)
    if (type === 'p') {
        const dir = isWhite ? -1 : 1;
        const startRank = isWhite ? 6 : 1;
        
        // Forward
        if (!state.board[rank + dir]?.[file]) {
            moves.push([file, rank + dir]);
            // Double push
            if (rank === startRank && !state.board[rank + dir * 2]?.[file]) {
                moves.push([file, rank + dir * 2]);
            }
        }
        
        // Captures
        [-1, 1].forEach(df => {
            const nf = file + df;
            const nr = rank + dir;
            if (nf >= 0 && nf < 8 && nr >= 0 && nr < 8) {
                const target = state.board[nr][nf];
                if (target && (target === target.toUpperCase()) !== isWhite) {
                    moves.push([nf, nr]);
                }
                // En passant (simplified check)
                if (!target && (rank === 3 || rank === 4)) {
                    moves.push([nf, nr]);
                }
            }
        });
    } else if (type === 'n') {
        [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(([df, dr]) => {
            const nf = file + df, nr = rank + dr;
            if (nf >= 0 && nf < 8 && nr >= 0 && nr < 8) {
                const target = state.board[nr][nf];
                if (!target || (target === target.toUpperCase()) !== isWhite) {
                    moves.push([nf, nr]);
                }
            }
        });
    } else if (type === 'k') {
        for (let dr = -1; dr <= 1; dr++) {
            for (let df = -1; df <= 1; df++) {
                if (dr === 0 && df === 0) continue;
                const nf = file + df, nr = rank + dr;
                if (nf >= 0 && nf < 8 && nr >= 0 && nr < 8) {
                    const target = state.board[nr][nf];
                    if (!target || (target === target.toUpperCase()) !== isWhite) {
                        moves.push([nf, nr]);
                    }
                }
            }
        }
        // Castling (simplified)
        if ((isWhite && rank === 7 && file === 4) || (!isWhite && rank === 0 && file === 4)) {
            moves.push([6, rank]); // Kingside
            moves.push([2, rank]); // Queenside
        }
    } else {
        // Sliding pieces (B, R, Q)
        const directions = [];
        if (type === 'b' || type === 'q') directions.push([-1,-1],[-1,1],[1,-1],[1,1]);
        if (type === 'r' || type === 'q') directions.push([-1,0],[1,0],[0,-1],[0,1]);
        
        directions.forEach(([df, dr]) => {
            for (let i = 1; i < 8; i++) {
                const nf = file + df * i, nr = rank + dr * i;
                if (nf < 0 || nf >= 8 || nr < 0 || nr >= 8) break;
                const target = state.board[nr][nf];
                if (!target) {
                    moves.push([nf, nr]);
                } else {
                    if ((target === target.toUpperCase()) !== isWhite) {
                        moves.push([nf, nr]);
                    }
                    break;
                }
            }
        });
    }
    
    return moves.map(([f, r]) => String.fromCharCode(97 + f) + (8 - r));
}

// ============================================
// Board Rendering
// ============================================

function renderBoard() {
    const container = $('board');
    container.innerHTML = '';
    
    const lastMove = state.currentGame?.moves?.slice(-1)[0];
    let lastFrom = null, lastTo = null;
    if (lastMove) {
        lastFrom = lastMove.slice(0, 2);
        lastTo = lastMove.slice(2, 4);
    }
    
    // Simple check detection - server handles check detection
    // Could highlight king in check here in the future
    
    for (let r = 0; r < 8; r++) {
        for (let f = 0; f < 8; f++) {
            const rank = state.orientation === 'white' ? r : 7 - r;
            const file = state.orientation === 'white' ? f : 7 - f;
            const square = String.fromCharCode(97 + file) + (8 - rank);
            const piece = state.board[rank][file];
            
            const div = document.createElement('div');
            div.className = 'square ' + ((rank + file) % 2 === 0 ? 'light' : 'dark');
            div.dataset.square = square;
            
            // Highlights
            if (square === lastFrom || square === lastTo) {
                div.classList.add('last-move');
            }
            if (square === state.selectedSquare) {
                div.classList.add('selected');
            }
            if (state.legalMoves.includes(square)) {
                div.classList.add(state.board[rank][file] ? 'legal-capture' : 'legal-move');
            }
            
            // Piece
            if (piece) {
                const span = document.createElement('span');
                span.className = 'piece ' + (piece === piece.toUpperCase() ? 'white' : 'black');
                span.textContent = getPieceSymbol(piece);
                div.appendChild(span);
            }
            
            div.onclick = () => handleSquareClick(square);
            container.appendChild(div);
        }
    }
}

function getPieceSymbol(piece) {
    const symbols = {
        'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
        'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
    };
    return symbols[piece] || '';
}

// ============================================
// Move Handling
// ============================================

function handleSquareClick(square) {
    if (!state.currentGame || state.currentGame.status !== 'started') return;
    
    const file = square.charCodeAt(0) - 97;
    const rank = 8 - parseInt(square[1]);
    const piece = state.board[rank][file];
    
    // Check if it's my turn
    const isWhiteTurn = (state.currentGame.moves?.length || 0) % 2 === 0;
    const isMyTurn = (state.orientation === 'white') === isWhiteTurn;
    
    if (!isMyTurn) return;
    
    if (state.selectedSquare) {
        // Second click - try to make move
        if (state.legalMoves.includes(square)) {
            makeMove(state.selectedSquare, square);
        } else if (piece) {
            // Select different piece
            const isWhite = piece === piece.toUpperCase();
            if ((state.orientation === 'white') === isWhite) {
                state.selectedSquare = square;
                state.legalMoves = getLegalMoves(square);
            } else {
                state.selectedSquare = null;
                state.legalMoves = [];
            }
        } else {
            state.selectedSquare = null;
            state.legalMoves = [];
        }
    } else {
        // First click - select piece
        if (piece) {
            const isWhite = piece === piece.toUpperCase();
            if ((state.orientation === 'white') === isWhite) {
                state.selectedSquare = square;
                state.legalMoves = getLegalMoves(square);
            }
        }
    }
    
    renderBoard();
}

function makeMove(from, to) {
    const fromFile = from.charCodeAt(0) - 97;
    const fromRank = 8 - parseInt(from[1]);
    const piece = state.board[fromRank][fromFile];
    
    // Check for promotion
    const toRank = 8 - parseInt(to[1]);
    const isPawn = piece.toLowerCase() === 'p';
    const isPromotion = isPawn && (toRank === 0 || toRank === 7);
    
    if (isPromotion) {
        state.pendingPromotion = { from, to };
        show('promotion-modal');
        return;
    }
    
    sendMove(from + to);
}

function selectPromotion(piece) {
    if (!state.pendingPromotion) return;
    
    const { from, to } = state.pendingPromotion;
    hide('promotion-modal');
    sendMove(from + to + piece);
    state.pendingPromotion = null;
}

async function sendMove(uci) {
    state.selectedSquare = null;
    state.legalMoves = [];
    renderBoard();

    try {
        const response = await fetchWithTimeout(
            CONFIG.LICHESS_HOST + '/api/board/game/' + state.currentGame.id + '/move/' + uci,
            {
                method: 'POST',
                headers: { 'Authorization': 'Bearer ' + state.token }
            },
            10000
        );

        if (!response.ok) {
            console.error('Move rejected');
            showError('Invalid move');
            // Move will be rejected, stream will update with correct state
        }
    } catch (err) {
        console.error('Failed to send move:', err);
        showError('Failed to send move');
    }
}

// ============================================
// Game Actions
// ============================================

async function resign() {
    if (!confirm('Are you sure you want to resign?')) return;

    try {
        await fetchWithTimeout(
            CONFIG.LICHESS_HOST + '/api/board/game/' + state.currentGame.id + '/resign',
            {
                method: 'POST',
                headers: { 'Authorization': 'Bearer ' + state.token }
            },
            10000
        );
    } catch (err) {
        console.error('Failed to resign:', err);
        showError('Failed to resign');
    }
}

async function offerDraw() {
    try {
        await fetchWithTimeout(
            CONFIG.LICHESS_HOST + '/api/board/game/' + state.currentGame.id + '/draw/yes',
            {
                method: 'POST',
                headers: { 'Authorization': 'Bearer ' + state.token }
            },
            10000
        );
        alert('Draw offer sent');
    } catch (err) {
        console.error('Failed to offer draw:', err);
        showError('Failed to offer draw');
    }
}

function backToLobby() {
    stopClockTimer();
    if (state.eventSource) {
        state.eventSource.close();
        state.eventSource = null;
    }
    showLobby();
}

function newGame() {
    stopClockTimer();
    if (state.eventSource) {
        state.eventSource.close();
        state.eventSource = null;
    }
    showLobby();
}

// ============================================
// Event Handlers Setup
// ============================================

function setupEventHandlers() {
    $('btn-login').onclick = startLogin;
    $('btn-logout').onclick = logout;
    $('btn-cancel-seek').onclick = cancelSeek;
    $('btn-back').onclick = backToLobby;
    $('btn-resign').onclick = resign;
    $('btn-draw').onclick = offerDraw;
    $('btn-new-game').onclick = newGame;
    $('btn-dismiss-error').onclick = dismissError;
    
    // Promotion buttons
    document.querySelectorAll('.promo-btn').forEach(btn => {
        btn.onclick = () => selectPromotion(btn.dataset.piece);
    });
}

// ============================================
// Initialization
// ============================================

function checkBrowserCompatibility() {
    console.log('=== Browser Compatibility Check ===');
    console.log('User Agent:', navigator.userAgent);
    console.log('TextEncoder:', typeof TextEncoder !== 'undefined' ? 'OK' : 'MISSING (polyfilled)');
    console.log('TextDecoder:', typeof TextDecoder !== 'undefined' ? 'OK' : 'MISSING (polyfilled)');
    console.log('crypto.subtle:', window.crypto && window.crypto.subtle ? 'OK' : 'MISSING (polyfilled)');
    console.log('URLSearchParams:', typeof URLSearchParams !== 'undefined' ? 'OK' : 'MISSING (polyfilled)');
    console.log('fetch:', typeof fetch !== 'undefined' ? 'OK' : 'MISSING');
    console.log('Promise:', typeof Promise !== 'undefined' ? 'OK' : 'MISSING');
    console.log('localStorage:', typeof localStorage !== 'undefined' ? 'OK' : 'MISSING');
    console.log('ReadableStream:', typeof ReadableStream !== 'undefined' ? 'OK' : 'MISSING');
    console.log('===================================');
}

async function init() {
    try {
        console.log('Initializing Lichess Kindle app...');

        // Check if polyfills loaded
        console.log('Polyfills check:');
        console.log('- window.POLYFILLS_LOADED = ' + (window.POLYFILLS_LOADED ? 'YES' : 'NO'));

        checkBrowserCompatibility();

        console.log('Setting up event handlers...');
        setupEventHandlers();
        console.log('Event handlers ready');

        // Show loading screen first
        console.log('Showing loading screen');
        showScreen('screen-loading');

        // Check for OAuth callback
        if (window.location.search.includes('code=')) {
            console.log('OAuth callback detected');
            const success = await handleOAuthCallback();
            if (success) {
                const authed = await checkAuth();
                if (authed) {
                    showLobby();
                    return;
                }
            }
            showScreen('screen-login');
            showError('Login failed. Please try again.');
            return;
        }

        // Check existing auth
        console.log('Checking for existing auth...');
        const authed = await checkAuth();
        if (authed) {
            console.log('Auth valid, showing lobby');
            showLobby();
        } else {
            console.log('No existing auth, showing login screen');
            showScreen('screen-login');
        }
    } catch (err) {
        console.error('CRITICAL: Init failed with error: ' + err.message);
        console.error('Error stack: ' + (err.stack || 'No stack trace'));
        showScreen('screen-login');
        showError('Initialization failed: ' + err.message);
    }
}

// Global error handler
window.addEventListener('error', function(e) {
    console.error('Global error: ' + e.message + ' at ' + e.filename + ':' + e.lineno);
});

window.addEventListener('unhandledrejection', function(e) {
    console.error('Unhandled promise rejection: ' + e.reason);
});

// Start app when DOM ready
console.log('=== APP LOADING ===');
console.log('DOM state: ' + document.readyState);

try {
    if (document.readyState === 'loading') {
        console.log('Waiting for DOM...');
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM ready, starting init');
            try {
                init();
            } catch (err) {
                console.error('Init failed: ' + err.message);
                console.error('Stack: ' + err.stack);
            }
        });
    } else {
        console.log('DOM already ready, starting init');
        init();
    }
} catch (err) {
    console.error('Critical error during startup: ' + err.message);
    console.error('Stack: ' + err.stack);
}
    </script>
</body>
</html>
